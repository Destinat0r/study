<div><br /></div><div>1. What is the difference between</div><div>JDK and JRE?</div><div><br /></div>	<div><br /></div><div>JDK stands for Java Development Kit. It contains the tools and</div><div>libraries for development of Java programs. It also contains</div><div>compilers and debuggers needed to compile Java program,</div><div>JRE stands for Java Runtime Environment. This is included in JDK.</div><div>JRE provides libraries and JVM that is required to run a Java</div><div>program.</div><div><br /></div>
<div>2. What is Java Virtual Machine</div><div>(JVM)?</div><div><br /></div>	<div>Java Virtual Machine (JVM) is an abstract machine that executes</div><div>Java Bytecode. There are different JVM for different hardware and</div><div>software platforms. So JVM is platform dependent. JVM is</div><div>responsible for loading, verifying and executing the Bytecode on a</div><div>platform.</div><div><br /></div>
<div>3. What are the different types of</div><div>memory areas allocated by JVM?</div>	<div>In java, JVM allocates memory to different processes, methods and</div><div>objects. Some of the memory areas allocated by JVM are:</div><div>1. &nbsp;ClassLoader: It is a component of JVM used to load class</div><div>files.</div><div>2. &nbsp;Class (Method) Area: It stores per-class structures such as</div><div>the runtime constant pool, field and method data, and the</div><div>code for methods.</div><div>3. &nbsp;Heap: Heap is created a runtime and it contains the runtime</div><div>data area in which objects are allocated.</div><div>4. &nbsp;Stack: Stack stores local variables and partial results at</div><div>runtime. It also helps in method invocation and return</div><div>value. Each thread creates a private JVM stack at the time</div><div>of thread creation.</div><div>5. &nbsp;Program Counter Register: This memory area contains the</div><div>address of the Java virtual machine instruction that is</div><div>currently being executed.</div><div>6. &nbsp;Native Method Stack: This area is reserved for all the</div><div>native methods used in the application.</div>
4. What is JIT compiler?	<div>Just In Time compiler also known as JIT compiler is used for</div><div>performance improvement in Java. It is enabled by default. It is</div><div>compilation done at execution time rather earlier.</div><div>Java has popularized the use of JIT compiler by including it in</div><div>JVM.</div>
<div>5. How Java platform is different</div><div>from other platforms?</div>	<div>Java is a platform independent language. Java compiler converts</div><div>Java code in to byte code that can be interpreted by JVM. There are</div><div>JVM written for almost all the popular platforms in the world.</div><div>Java byte code can run on any supported platform in same way.</div><div>Where as other languages require libraries compiled for a specific</div><div>platform to run.</div>
<div>6. Why people say that Java is 'write</div><div>once and run anywhere' language?</div>	<div>You can write Java code on Windows and compile it in Windows</div><div>platform. The class and jar files that you get from Windows</div><div>platform can run as it is on Unix environment. So it is a truly</div><div>platform independent language.</div><div>Behind all this portability is Java byte code. Byte code generated by</div><div>Java compiler can be interpreted by any JVM. So it becomes much</div><div>easier to write programs in Java and expect those to run on any</div><div>platform.</div><div>Java compiler javac compiles java code and JVM java runs that</div><div>code.</div>
<div>7. How does ClassLoader work in</div><div>Java?</div>	<div>In Java, ClassLoader is a class that is used to load files in JVM.</div><div>ClassLoader loads files from their physical file locations e.g.</div><div>Filesystem, Network location etc.</div><div>There are three main types of ClassLoaders in Java.</div><div>1. &nbsp;Bootstrap ClassLoader: This is the first ClassLoader. It</div><div>loads classes from rt.jar file.</div><div>2. &nbsp;Extension ClassLoader: It loads class files from jre/lib/ext</div><div>location.</div><div>3. &nbsp;Application ClassLoader: This ClassLoader depends on</div><div>CLASSPATH to find the location of class files. If you</div><div>specify your jars in CLASSPATH, then this ClassLoader</div><div>will load them.</div>
<div>8. Do you think ‘main’ used for main</div><div>method is a keyword in Java?</div>	<div>No, main is just a name of method. There can be multiple methods</div><div>with same name main in a class file. It is not a keyword in Java.</div>
<div>9. Can we write main method as</div><div>public void static instead of public</div><div>static void?</div>	<div>No, you cannot write it like this. Any method has to first specify the</div><div>modifiers and then the return value. The order of modifiers can</div><div>change.</div><div>We can write static public void main() instead of public static void</div><div>main().</div><div><br /></div>
<div>10. In Java, if we do not specify any</div><div>value for local variables, then what</div><div>will be the default value of the local</div><div>variables?</div><div><br /></div>	<div>Java does not initialize local variables with any default value. So</div><div>these variables will be just null by default.</div><div><br /></div>
<div>11. Let say, we run a java class without</div><div>passing any arguments. What will be</div><div>the value of String array of</div><div>arguments in Main method?</div><div><br /></div>	<div>By default, the value of String array of arguments is empty in Java.</div><div>It is not null.</div><div><br /></div>
<div>12. What is the difference between</div><div>byte and char data types in Java?</div><div><br /></div>	<div>Both byte and char are numeric data types in Java. They are used to</div><div>represent numbers in a specific range.</div><div>Major difference between them is that a byte can store raw binary</div><div>data where as a char stores characters or text data.</div><div>Usage of char is E.g. char ch = ‘x’;</div><div>Byte values range from -128 to 127.</div><div>A byte is made of 8 bits. But a char is made of 16 bits. So it is</div><div>equivalent to 2 bytes.</div><div><br /></div>
<div>13. What are the main principles of</div><div>Object Oriented Programming?</div><div><br /></div>	<div>Main principles of Object Oriented Programming (OOPS) are:</div><div>1. &nbsp;Abstraction</div><div>2. &nbsp;Encapsulation</div><div>3. &nbsp;Inheritance</div><div>4. &nbsp;Polymorphism</div><div><br /></div>
<div>14. What is the difference between</div><div>Object Oriented Programming</div><div>language and Object Based</div><div>Programming language?</div><div><br /></div>	<div>Object Oriented Programming languages like Java and C++ follow</div><div>concepts of OOPS like- Encapsulation, Abstraction, Polymorphism</div><div>and Inheritance etc.</div><div>Object Based Programming languages follow some features of</div><div>OOPS but they do not provide support for Polymorphism and</div><div>Inheritance. Egg. JavaScript, VBScript etc.</div><div>Object Based Programming languages provide support for Objects</div><div>and you can build objects from constructor. They languages also</div><div>support Encapsulation. These are also known as Prototype-oriented</div><div>languages.</div><div><br /></div>
<div>15. In Java what is the default value of</div><div>an object reference defined as an</div><div>instance variable in an Object?</div><div><br /></div>	<div>All the instance variable object references in Java are null.</div><div><br /></div>
<div>16. Why do we need constructor in</div><div>Java?</div><div><br /></div>	<div>Java is an object-oriented language, in which we create and use</div><div>objects. A constructor is a piece of code similar to a method. It is</div><div>used to create an object and set the initial state of the object.</div><div>A constructor is a special function that has same name as class</div><div>name.</div><div>Without a constructor, there is no other way to create an object.</div><div>By default, Java provides a default constructor for every object. If</div><div>we overload a constructor then we have to implement default</div><div>constructor.</div><div><br /></div>
<div>17. Why do we need default</div><div>constructor in Java classes?</div><div><br /></div>	<div>Default constructor is the no-argument constructor that is</div><div>automatically generated by Java if no other constructor is defined.</div><div>Java specification says that it will provide a default constructor if</div><div>there is no overloaded constructor in a class. But it does not say</div><div>anything about the scenario in which we write an overloaded</div><div>constructor in a class.</div><div>We need at least one constructor to create an object, that’s why Java</div><div>provides a default constructor.</div><div>When we have overloaded constructor, then Java assumes that we</div><div>want some custom treatment in our code. Due to which it does not</div><div>provide default constructor. But it needs default constructor as per</div><div>the specification. So it gives error.</div><div><br /></div>
<div>18. What is the value returned by</div><div>Constructor in Java?</div><div><br /></div>	<div>When we call a constructor in Java, it returns the object created by</div><div>it. That is how we create new objects in Java.</div><div><br /></div>
<div>19. Can we inherit a Constructor?</div><div><br /></div>	<div>No, Java does not support inheritance of constructor.</div><div><br /></div>
<div>20. Why constructors cannot be final,</div><div>static, or abstract in Java?</div><div><br /></div>	<div>If we set a method as final it means we do not want any class to</div><div>override it. But the constructor (as per Java Language</div><div>Specification) cannot be overridden. So there is no use of marking it</div><div>final.</div><div>If we set a method as abstract it means that it has no body and it</div><div>should be implemented in a child class. But the constructor is called</div><div>implicitly when the new keyword is used. Therefore it needs a</div><div>body.</div><div>If we set a method as static it means that it belongs to the class, but</div><div>not a particular object. The constructor is always called to initialize</div><div>an object. Therefore, there is no use of marking constructor static.</div><div>Inheritance</div><div><br /></div>
<div>21. What is the purpose of ‘this’</div><div>keyword in java?</div><div><br /></div>	<div>In Java, ‘this’ keyword refers to current instance of the object.</div><div>It is useful for differentiating between instance variables and local</div><div>variables.</div><div>It can be used to call constructors. Or it can be used to refer to the</div><div>instance.</div><div>In case of method overriding, this is used for falling the method of</div><div>current class.</div><div><br /></div>
<div>22. Explain the concept of</div><div>Inheritance?</div><div><br /></div>	<div>Inheritance is an important concept in Object Oriented</div><div>Programming. Some objects share certain characteristics and</div><div>behavior. By using Inheritance, we can put the common behavior</div><div>and characteristics in a base class which also known as super class.</div><div>And then all the objects with common behavior inherit from this</div><div>base class.</div><div>It is also represented by IS-A relationship.</div><div>Inheritance promotes, code reuse, method overriding and poly-</div><div>morphism.</div><div><br /></div>
<div>23. Which class in Java is superclass</div><div>of every other class?</div><div><br /></div>	<div>Java is an object oriented programming language. In Java, Object</div><div>class is the superclass of every other class.</div><div><br /></div>
<div>24. Why Java does not support</div><div>multiple inheritance?</div><div><br /></div>	<div>Multiple Inheritance means that a class can inherit behavior from</div><div>two or more parent classes.</div><div>The issue with Multiple Inheritance is that both the parent classes</div><div>may have different implementation for the same method. So they</div><div>have different ways of doing the same thing. Now which</div><div>implementation should the child class choose?</div><div>This leads to ambiguity in Multiple Inheritance. This is the main</div><div>reason &nbsp;for &nbsp;Java &nbsp;not &nbsp;supporting &nbsp;Multiple &nbsp;Inheritance &nbsp;in</div><div>implementation.</div><div>Lets say you have a class TV and another class AtomBomb. Both</div><div>have method switchOn() but only TV has switchOff() method. If</div><div>your class inherits from both these classes then you have an issue</div><div>that you can switchOn() both parents, but switchOff will only</div><div>switchOff() TV.</div><div>But you can implement multiple interfaces in Java.</div><div><br /></div>
<div>25. In OOPS, what is meant by</div><div>composition?</div><div><br /></div>	<div>Composition is also known as “has-a” relationship. In composition,</div><div>“has-a” relation relates two classes. E.g. Class Car has a steering</div><div>wheel.</div><div>If a class holds the instance of another class, then it is called</div><div>composition.</div><div><br /></div>
<div>26. How aggregation and composition</div><div>are different concepts?</div><div><br /></div>	<div>In OOPS, Aggregation and Composition are the types of association</div><div>relations. A composition is a strong relationship. If the composite</div><div>object is destroyed, then all its parts are destroyed. E.g. A Car has a</div><div>Steering Wheel. If Car object is destroyed, then there is no meaning</div><div>of Steering Wheel.</div><div>In Aggregation, the relationship is weaker than Composition.</div><div>E.g. A Library has students. If a Library is destroyed, Students still</div><div>exist. So Library and Student are related by Aggregation. A Library</div><div>has Books. If Library is destroyed, the Books are also destroyed.</div><div>Books of a Library cannot exist without the Library. So Book and</div><div>Library are related by Composition.</div><div><br /></div>
<div>27. Why there are no pointers in</div><div>Java?</div><div><br /></div>	<div>In Java there are references instead of pointers. These references</div><div>point to objects in memory. But there is no direct access to these</div><div>memory locations. JVM is free to move the objects within VM</div><div>memory.</div><div>The absence of pointers helps Java in managing memory and</div><div>garbage collection effectively. Also it provides developers with</div><div>convenience of not getting worried about memory allocation and de-</div><div>allocation.</div><div><br /></div>
<div>28. If there are no pointers in Java,</div><div>then why do we get</div><div>NullPointerException?</div><div><br /></div>	<div>In Java, the pointer equivalent is Object reference. When we use a .</div><div>it points to object reference. So JVM uses pointers but</div><div>programmers only see object references.</div><div>In case an object reference points to null object, and we try to</div><div>access a method or member variable on it, then we get</div><div>NullPointerException.</div><div><br /></div>
<div>29. What is the purpose of ‘super’</div><div>keyword in java?</div><div><br /></div>	<div>‘super’ keyword is used in the methods or constructor of a child</div><div>class. It refers to immediate parent class of an object.</div><div>By using ‘super’ we can call a method of parent class from the</div><div>method of a child class.</div><div>We can also call the constructor of a parent class from the</div><div>constructor of a child class by using ‘super’ keyword.</div><div><br /></div>
<div>30. Is it possible to use this() and</div><div>super() both in same constructor?</div><div><br /></div>	<div>No, Java does not allow using both super() and this() in same</div><div>constructor. As per Java specification, super() or this() must be the</div><div>first statement in a constructor.</div><div><br /></div>
<div>31. What is the meaning of object</div><div>cloning in Java?</div><div><br /></div>	<div>Object.clone() method is used for creating an exact copy of the</div><div>object in Java. It acts like a copy constructor. It creates and returns</div><div>a copy of the object, with the same class and with all the fields</div><div>having same values as of the original object.</div><div>One disadvantage of cloning is that the return type is an Object. It</div><div>has to be explicitly cast to actual type.</div><div><br /></div>
<div>32. In Java, why do we use static</div><div>variable?</div><div><br /></div>	<div>Whenever we want to have a common property for all objects of a</div><div>class, we use a class level variable i.e. a static variable.</div><div>This variable is loaded in memory only once at the time of class</div><div>loading. So it saves memory, since it is not defined per object in</div><div>Java.</div><div><br /></div>
<div>33. Why it is not a good practice to</div><div>create static variables in Java?</div><div><br /></div>	<div>Static variables are common to all the objects of a class. If a new</div><div>object is created, there is no need to test the value of static variable.</div><div>Any code that uses static variable can be in any state. It can be</div><div>within a new object or at a class level. So the scope of static</div><div>variable is open ended in a Java class.</div><div>If we want tighter control on scope, then variables should be</div><div>created at the object creation level.</div><div>Also defining static variables is not a good practice because they go</div><div>against the principles of Object Oriented Programming.</div><div><br /></div>
<div>34. What is the purpose of static</div><div>method in Java?</div><div><br /></div>	<div>Java provides the feature of static method to create behavior at the</div><div>class level. The static method is common to all the objects of a</div><div>class. We do not need to create any object of a class to call a static</div><div>method. So it provides convenience of not creating an object for</div><div>calling it.</div><div>Also a static method can access and modify static data members.</div><div>This also helps in keeping the behavior as well as state at the class</div><div>level.</div><div><br /></div>
<div>35. Why do we mark main method as</div><div>static in Java?</div><div><br /></div>	<div>The main method in Java is marked as static, so that JVM can call it</div><div>to start the program. If main method is not static, then which</div><div>constructor will be called by Java process?</div><div>As such it is a known as convention to mark main method static in</div><div>Java. But if we remove the static, then there will be ambiguity. Java</div><div>process may not know which method of a class to call to start the</div><div>program.</div><div>So this convention helps in Java process to identify the starting code</div><div>for a program in class that is passed as an argument to java process.</div><div><br /></div>
<div>36. In what scenario do we use a static</div><div>block?</div><div><br /></div>	<div>At times, there is a class that has static member variables. These</div><div>variables need some complicated initialization. At this time static</div><div>block helps as a tool to initialize complex static member variable</div><div>initialization.</div><div>The static block is executed even before the execution of main.</div><div>Sometimes, we can also replace static block with a static method of</div><div>class.</div><div><br /></div>
<div>37. Is it possible to execute a program</div><div>without defining a main() method?</div><div><br /></div>	<div>No, with Java 7 onwards, you need a main() method to execute a</div><div>program. In earlier versions of Java, there was a workaround</div><div>available to use static blocks for execution. But now this gap has</div><div>been closed.</div><div><br /></div>
<div>38. What happens when static</div><div>modifier is not mentioned in the</div><div>signature of main method?</div><div><br /></div>	<div>As per Java specification, main method has to be marked as static.</div><div>It needs only one argument that is an array of String.</div><div>A program can compile with a non-static method. But on execution</div><div>it will give NoSuchMethodError.</div><div><br /></div>
<div>39. What is the difference between</div><div>static method and instance method in</div><div>Java?</div><div><br /></div>	<div>Often, there is a need to define a behavior for a class that is not</div><div>dependent on member variables of an object. Such behavior is</div><div>captured in a static method. If there is a behavior dependent upon</div><div>the member variables of an object, then we do not mark it static, it</div><div>remains as instance method.</div><div>To call as static method, we do not need to create an object. We just</div><div>call it with class name. But to call an instance method, we need to</div><div>create/get an object first.</div><div>Instance member variables cannot be accessed by a static method.</div><div>But an instance method can call both instance variables and static</div><div>variables.</div><div><br /></div><div><br /></div>
<div>40. What is the other name of Method</div><div>Overloading?</div><div><br /></div>	<div>Method Overloading is also known as Static Polymorphism.</div><div><br /></div>
<div>41. How will you implement method</div><div>overloading in Java?</div><div><br /></div>	<div>In Java, a class can have multiple methods with same name but</div><div>different arguments. It is called Method Overloading. To implement</div><div>method overloading we have to create two methods with same name</div><div>in a class and do one/more of the following:</div><div><br /></div><div>1. &nbsp;Different number of parameters</div><div>2. &nbsp;Different data type of parameters</div><div>3. &nbsp;Different sequence of data type of parameters</div>
<div>42. What kinds of argument</div><div>variations are allowed in Method</div><div>Overloading?</div><div><br /></div>	<div>Method Overloading allows two methods with same name to differ</div><div>in:</div><div>1. &nbsp;Number of parameters</div><div>2. &nbsp;Data type of parameters</div><div>3. &nbsp;Sequence of data type of parameters</div><div><br /></div>
<div>43. Why it is not possible to do</div><div>method overloading by changing</div><div>return type of method in java?</div><div><br /></div>	<div>If we change the return type of overloaded methods then it will lead</div><div>to ambiguous behavior. How will clients know which method will</div><div>return what type. Due to this different return type are not allowed in</div><div>overloaded methods.</div><div><br /></div>
<div>44. Is it allowed to overload main()</div><div>method in Java?</div><div><br /></div>	<div>Yes, Java allows users to create many methods with same name</div><div>‘main’. But only public static void main(String[] args) method is</div><div>used for execution.</div><div><br /></div>
<div>45. How do we implement method</div><div>overriding in Java?</div><div><br /></div>	<div>To override a method, we just provide a new implementation of a</div><div>method with same name in subclass. So there will be at least two</div><div>implementations &nbsp;of &nbsp;the &nbsp;method &nbsp;with &nbsp;same &nbsp;name. &nbsp;One</div><div>implementation is in parent class. And another implementation is in</div><div>child class.</div><div><br /></div>
<div>46. Are we allowed to override a static</div><div>method in Java?</div><div><br /></div>	<div>No. Java does not allow overriding a static method. If you create a</div><div>static method with same name in subclass, then it is a new method,</div><div>not an overridden method.</div><div><br /></div>
<div>47. Why Java does not allow</div><div>overriding a static method?</div><div><br /></div>	<div>To override a method, you need an instance of a class. Static method</div><div>is not associated with any instance of the class. So the concept of</div><div>overriding does not apply here.</div><div>Therefore, Java does not allow overriding a static method.</div><div><br /></div>
<div>48. Is it allowed to override an</div><div>overloaded method?</div><div><br /></div>	<div>Yes. You can override an overloaded method in Java.</div><div><br /></div>
<div>49. What is the difference between</div><div>method overloading and method</div><div>overriding in Java?</div><div><br /></div>	<div>Differences between method overloading and overriding are:</div><div>1. &nbsp;Method overloading is static polymorphism. Method</div><div>overriding is runtime polymorphism.</div><div>2. &nbsp;Method overloading occurs within the same class. Method</div><div>overriding happens in two classes with hierarchy</div><div>relationship.</div><div>3. &nbsp;Parameters must be different in method overloading.</div><div>Parameters must be same in method overriding.</div><div>4. &nbsp;Method overloading is a compile time concept. Method</div><div>overriding is a runtime concept.</div><div><br /></div>
<div>50. Does Java allow virtual functions?</div><div><br /></div>	<div>Yes. All instance methods in Java are virtual functions by default.</div><div>Only class methods and private instance methods are not virtual</div><div>methods in Java.</div><div><br /></div>
<div>51. What is meant by covariant return</div><div>type in Java?</div><div><br /></div>	"<div>A covariant return type of a method is one that can be replaced by a</div><div>""narrower"" type when the method is overridden in a subclass.</div><div>Let say class B is child of class A. There is a get() method in class</div><div>A as well as class B. get() method of class A can return an instance</div><div>of A, and get() method of class B return an instance of B. Here</div><div>class B overrides get() method, but the return type is different.</div><div>Before Java 5, any method that overrides the method of parent class</div><div>would have same return type.</div><div>From Java 5 onwards, a child class can override a method of parent</div><div>class and the child class method can return an object that is child of</div><div>object return by parent class method.</div><div><br /></div>"
<div>52. What is Runtime Polymorphism?</div><div><br /></div>	<div>Runtime Polymorphism or Dynamic Polymorphism is the</div><div>polymorphism that exists at runtime. In case of method overriding it</div><div>is not known which method will be called at runtime. Based on the</div><div>type of object, JVM decides the exact method that should be called.</div><div>So at compile time it is not known which method will be called at</div><div>run time.</div><div><br /></div>
<div>53. Is it possible to achieve Runtime</div><div>Polymorphism by data members in</div><div>Java?</div><div><br /></div>	<div>No. We need to create Runtime Polymorphism by implementing</div><div>methods at two levels of inheritance in Java.</div><div><br /></div>
<div>54. Explain the difference between</div><div>static and dynamic binding?</div><div><br /></div>	"<div>In Static binding references are resolved at compile time. In</div><div>Dynamic binding references are resolved at Run time.</div><div>E.g.</div><div><pre class=""myCodeClass"">Person p = new Person(); <br /></pre><pre class=""myCodeClass"">p.walk(); // Java compiler resolves this binding at compile time. <br /></pre><pre class=""myCodeClass"">public void walk(Object o) { ((Person) o).walk(); // this is dynamic binding. } </pre></div>"
<div>55. What is Abstraction in Object</div><div>Oriented programming?</div><div><br /></div>	<div>Abstraction is the process of hiding certain implementation details</div><div>of an object and showing only essential features of the object to</div><div>outside world.</div><div>It is different from Abstract class in Java.</div><div>Abstraction process identifies commonalities and hides the</div><div>complexity of implementation. It helps us in focusing on the</div><div>interface that we share with the outside world.</div><div><br /></div>
<div>56. How is Abstraction different from</div><div>Encapsulation?</div><div><br /></div>	<div>Abstraction happens at class level design. It results in hiding the</div><div>implementation &nbsp;details. &nbsp;Encapsulation &nbsp;is &nbsp;also &nbsp;known &nbsp;as</div><div>“Information Hiding”. An example of encapsulation is marking the</div><div>member variables private and providing getter and setter for these</div><div>member variables.</div><div><br /></div>
<div>57. What is an abstract class in Java?</div><div><br /></div>	<div>An abstract class in Java has one or more abstract methods. An</div><div>abstract method is just declared in the abstract class, but it is not</div><div>implemented.</div><div>An abstract class has to be extended in Java and its abstract</div><div>methods have to be implemented by a child class. Also Java does</div><div>not allow new instance of Abstract class.</div><div><br /></div>
<div>58. Is it allowed to mark a method</div><div>abstract method without marking the</div><div>class abstract?</div><div><br /></div>	<div>No. Java specification says that if there is at least one abstract</div><div>method in a class, the class has to be marked abstract.</div><div><br /></div>
<div>59. Is it allowed to mark a method</div><div>abstract as well as final?</div><div><br /></div>	<div>No. It will be contradictory statement to mark a method abstract as</div><div>well as final.</div><div>An abstract method has to be overridden by a child class. And a</div><div>final method cannot be overridden. Therefore a method can be</div><div>either abstract or final in Java.</div><div><br /></div>
<div>60. Can we instantiate an abstract</div><div>class in Java?</div><div><br /></div>	<div>No. We cannot create an instance of an abstract class in Java.</div><div><br /></div>
<div>61. What is an interface in Java?</div><div><br /></div>	<div>An Interface in Java is an abstract type blueprint of a class. It</div><div>contains the methods that a class must implement. It is like a</div><div>protocol.</div><div>It has method signatures and constant declarations.</div><div><br /></div>
<div>62. Is it allowed to mark an interface</div><div>method as static?</div><div><br /></div>	<div>Yes, from Java 8 onwards, we can define static and default methods</div><div>in an interface. Prior to Java 8, it was not allowed.</div><div><br /></div>
<div>63. Why an Interface cannot be</div><div>marked as final in Java?</div><div><br /></div>	<div>A final method cannot be overridden. But an interface method has to</div><div>be implemented by another class. So the interface method cannot be</div><div>marked as final.</div><div><br /></div>
<div>64. What is a marker interface?</div><div><br /></div>	<div>There are interfaces that do not have any data member or methods.</div><div>These interfaces are called Marker interface.</div><div>E.g. Serializable, Cloneable, Remote etc.</div><div><br /></div>
<div>65. What can we use instead of</div><div>Marker interface?</div><div><br /></div>	<div>We can use annotations instead of Marker interface.</div><div><br /></div>
<div>66. How Annotations are better than</div><div>Marker Interfaces?</div><div><br /></div>	"<div>Annotations serve the purpose of conveying metadata about the</div><div>class to its consumers without creating a separate type for it.</div><div>Annotations are more powerful than a Marker interface. They allow</div><div>programmers to pass more sophisticated information to classes that</div><div>""consume"" it.</div><div><br /></div>"
<div>67. What is the difference between</div><div>abstract class and interface in Java?</div><div><br /></div>	<div>Differences between Abstract class and Interface are as follows:</div><div>1. &nbsp;An abstract class can have implemented methods with</div><div>body (non-abstract methods). Interface has only abstract</div><div>methods. From Java 8 onwards, interface can have</div><div>static/default methods in implemented form.</div><div>2. &nbsp;An abstract class can have instance member variables. An</div><div>interface cannot have instance variables. It can only have</div><div>constants.</div><div>3. &nbsp;An abstract class can have a constructor. Interface cannot</div><div>have constructor. It has to be implemented by another</div><div>class.</div><div>4. &nbsp;A class can extend only one abstract class. A class can</div><div>implement more than one interface.</div><div><br /></div>
<div>68. Does Java allow us to use private</div><div>and protected modifiers for variables</div><div>in interfaces?</div><div><br /></div>	<div>No. All the variables in an interface are implicitly public.</div><div><br /></div>
<div>69. How can we cast to an object</div><div>reference to an interface reference?</div><div><br /></div>	<div>An Object that implements an Interface can be cast to the same</div><div>Interface. Since An Object implementing an Interface already</div><div>provides implementation for the methods of that Interface, it is</div><div>allowed to do so as per the rules of Inheritance.</div><div><br /></div>
<div>70. How can you change the value of a</div><div>final variable in Java?</div><div><br /></div>	<div>Java does not allow changing the value of a final variable. Once the</div><div>value is set, it cannot be changed.</div><div><br /></div>
<div>71. Can a class be marked final in</div><div>Java?</div><div><br /></div>	<div>Yes a class can be marked final in Java. Once a class is marked</div><div>final, it cannot be extended.</div><div><br /></div>
<div>72. How can we create a final method</div><div>in Java?</div><div><br /></div>	<div>To mark a method, add modifier final to that method. A final method</div><div>can not be overridden by a child class.</div><div><br /></div>
<div>73. How can we prohibit inheritance</div><div>in Java?</div><div><br /></div>	<div>If you mark a class final, it cannot be extended. This will prohibit</div><div>the inheritance of that class in Java.</div><div><br /></div>
<div>74. Why Integer class in final in Java?</div><div><br /></div>	<div>Integer class is a wrapper for int. If it is not marked final, then any</div><div>other class can extend it and modify the behavior of Integer</div><div>operations. To avoid this Integer wrapper class is marked as final.</div><div><br /></div>
<div>75. What is a blank final variable in</div><div>Java?</div><div><br /></div>	<div>When we declare a final variable without giving any initial value,</div><div>then it is called blank final variable.</div><div><br /></div>
<div>76. How can we initialize a blank final</div><div>variable?</div><div><br /></div>	<div>A blank final instance variable can be initialized in a constructor.</div><div>A blank final static variable can be initialized in the static block of</div><div>class.</div><div><br /></div>
<div>77. Is it allowed to declare main</div><div>method as final?</div><div><br /></div>	<div>Yes, we can mark the main method as final.</div><div><br /></div>
<div>78. What is the purpose of package in</div><div>Java?</div><div><br /></div>	<div>A package is used to encapsulate a group of classes, interfaces and</div><div>sub-packages. Often, it is a hierarchical structure of storing</div><div>information. It is easier to organize the related classes and sub-</div><div>packages in this manner.</div><div>A Package also provides access protection for classes and</div><div>interfaces. A package also helps in removing naming collision.</div><div><br /></div>
<div>79. What is java.lang package?</div><div><br /></div>	<div>In Java, java.lang package contains the classes that are fundamental</div><div>to the design of Java programming language. The most important</div><div>class in this package is Object class.</div><div>It also contains wrapper classes like- Integer, Boolean, Character</div><div>etc. It provides Math class for mathematical operations.</div><div><br /></div>
<div>80. Which is the most important class</div><div>in Java?</div><div><br /></div>	<div>It is an open-ended question with many answers. In my view, Object</div><div>class is the most important class of Java programming language. It</div><div>is the root of all the classes in Java. It provides some very</div><div>important and fundamental methods.</div><div><br /></div>
<div>81. Is it mandatory to import java.lang</div><div>package every time?</div><div><br /></div>	<div>No. By default, JVM loads it internally.</div><div><br /></div>
<div>82. Can you import same package or</div><div>class twice in your class?</div><div><br /></div>	<div>If we import same package multiple times in a class, compiler</div><div>includes it only once. So neither JVM nor Compiler gives any</div><div>error/warning on including a package multiple times.</div><div>If you have two classes with same name, then you may get name</div><div>collision on importing the class erroneously.</div><div>JVM internally loads the class only one time.</div><div><br /></div>
<div>83. What is a static import in Java?</div><div><br /></div>	<div>Static import is similar to normal import declaration. Normal</div><div>import allows us to import classes from packages without using</div><div>package qualifier. Static import allows us to import static members</div><div>from a class without using class qualifier.</div><div><br /></div>
<div>84. What is the difference between</div><div>import static com.test.Fooclass and</div><div>import com.test.Fooclass?</div><div><br /></div>	<div>First import is a static import and the second import is normal</div><div>import of a class. First import allows us to import static members of</div><div>class.</div><div><br /></div>
<div>85. What is Locale in Java?</div><div><br /></div>	<div>A Locale object represents a specific geographical, political, or</div><div>cultural region. It is used to locale-sensitive operations in Java.</div><div>It helps is following the local conventions of a country, native or</div><div>region. These conventions can be for formatting the dates, money,</div><div>numbers etc.</div><div><br /></div>
<div>86. How will you use a specific Locale</div><div>in Java?</div><div><br /></div>	"<div>To use a specific Locale, we need to load that Locale. We can use</div><div>ResourceBundle.getBundle(""Locale.UK"") method to load a Locale.</div><div><br /></div>"
<div>87. What is the serialization?</div><div><br /></div>	<div>Serialization is a process converting an object into a byte array.</div><div>This byte array represents the class, version and internal state of the</div><div>object. JVM can use this byte array to transmit/read the object over</div><div>a network.</div><div><br /></div>
<div>88. What is the purpose of</div><div>serialization?</div><div><br /></div>	<div>Some of the uses of serialization are:</div><div>1. &nbsp;Communication: It is used for transmitting an object over</div><div>network between two machines.</div><div>2. &nbsp;Persistence: We can store the object’s state in a database</div><div>and retrieve it from database later on.</div><div>3. &nbsp;Caching: Serialization can be used for caching to improve</div><div>performance. We may need 10 minutes to build an object,</div><div>but it may take just 10 seconds to de-serialize the object.</div><div>4. &nbsp;Cross JVM Synchronization: It can be used in same way</div><div>across multiple JVM that follow different architecture.</div><div><br /></div>
<div>89. What is Deserialization?</div><div><br /></div>	<div>Deserialization is the process of reconstructing the object from the</div><div>serialized state. It is the reverse process of serialization.</div><div><br /></div>
<div>90. What is Serialization and</div><div>Deserialization conceptually?</div><div><br /></div>	<div>Serialization is to convert Object data into a stream of bytes</div><div>Deserialization is to convert a stream of bytes back into a copy of</div><div>the original object.</div><div><br /></div>
<div>91. Why do we mark a data member</div><div>transient?</div><div><br /></div>	<div>Member variables of an object are marked transient to indicate that</div><div>they should not be serialized.</div><div>During serialization process the transient variables are not</div><div>considered part of the persistent state of an object.</div><div><br /></div>
<div>92. Is it allowed to mark a method as</div><div>transient?</div><div><br /></div>	<div>No, Java does not allow marking a method as transient. The</div><div>transient keyword is valid only for member variables.</div><div><br /></div>
<div>93. How does marking a field as</div><div>transient makes it possible to serialize</div><div>an object?</div><div><br /></div>	<div>Let say we have a class ABC that implements Serializable</div><div>interface, but it contains a member variable object of class XYZ</div><div>that does not implement Serializable interface. Due to this it is not</div><div>possible to Serialize the class ABC.</div><div>To solve this issue, we can mark the member variable XYZ as</div><div>Transient in class ABC. This will allow us to serialize the class</div><div>ABC.</div><div><br /></div>
<div>94. What is Externalizable interface</div><div>in Java?</div><div><br /></div>	<div>Externalizable interface extends Serializable interface in Java. It is</div><div>used for giving the Class control over saving and restoring the</div><div>contents of its instances.</div><div>A class implements methods writeExternal() and readExternal() to</div><div>store and restore the object.</div><div><br /></div>
<div>95. What is the difference between</div><div>Serializable and Externalizable</div><div>interface?</div><div><br /></div>	<div>Serializable is a marker interface but Externalizable is not a marker</div><div>interface.</div><div>When we implement Serializable interface, the class is serialized</div><div>automatically by default. We can override writeObject() and</div><div>readObject()methods to control more complex object Serialization</div><div>process.</div><div>In &nbsp;case &nbsp;of &nbsp;Externalizable, &nbsp;we &nbsp;use &nbsp;readExternal() &nbsp;and</div><div>writeExternal() methods to give control to class for class's</div><div>serialization process.</div><div>Serializable interface is based on recursive algorithm.</div><div>Serializable gives you two options. One option is to provide custom</div><div>way of serialization, the other default way. In Externalizable, you</div><div>have to always implement readExternal() and writeExternal()</div><div>methods.</div><div>A public no-arg constructor is needed while using Externalizable</div><div>interface.</div><div>In Serialization, we need to define serialVersionUID. If it is not</div><div>explicitly defined it will be generated automatically based on all the</div><div>fields, methods of the class.</div><div><br /></div>
<div>96. What is Reflection in Java?</div><div><br /></div>	<div>Reflection is Java language's ability to inspect and dynamically call</div><div>classes, methods, attributes etc. at Runtime. It helps in examining or</div><div>modifying the Runtime behavior of a class at Runtime.</div><div><br /></div>
<div>97. What are the uses of Reflection in</div><div>Java?</div><div><br /></div>	"<div>Reflection is often used in Testing, Debugging and in Integrated</div><div>Development Environment (IDE).</div><div>Reflection allows you to write programs that do not have to ""know""</div><div>everything at compile time. It makes programs more dynamic, since</div><div>they can be tied together at runtime.</div><div>Many modern frameworks like Spring etc. use Reflection. Some</div><div>modern languages like Python etc. also use Reflection.</div><div>JAVA API for XML Parsing (JAXP) also uses Reflection.</div><div><br /></div>"
<div>98. How can we access private</div><div>method of a class from outside the</div><div>class?</div><div><br /></div>	"<p>We can use Reflection to access private method of a class from<br /> outside the class. IN Java, we use getDeclaredMethod() to get<br /> instance of a private method. Then we mark this method accessible<br /> and finally invoke it.<br /> In following sample code, we are accessing private method<br /> message() of class Foo by Reflection.</p> <p>FileName: Foo.java</p> <table class=""codehilitetable""><tbody><tr><td><div class=""linenodiv"" style=""background-color: #f0f0f0; padding-right: 10px""><pre style=""line-height: 125%"">1 2 3</pre></div></td><td class=""code""><div class=""codehilite"" style=""background: #f8f8f8"" align=""left""><pre style=""line-height: 125%"">public class Foo {   private void message(){System.out.println(""hello java""); } } </pre></div> </td></tr></tbody></table> <p>FileName: FooMethodCall.java</p> <table class=""codehilitetable""><tbody><tr><td><div class=""linenodiv"" style=""background-color: #f0f0f0; padding-right: 10px""><pre style=""line-height: 125%""> 1  2  3  4  5  6  7  8  9 10 11 12 13 14</pre></div></td><td class=""code""><div class=""codehilite"" style=""background: #f8f8f8"" align=""left""><pre style=""line-height: 125%""><span style=""color: #204a87;font-weight: bold"">import</span> <span style=""color: #000000"">java.lang.reflect.Method</span><span style=""color: #000000; font-weight: bold"">;</span>   <span style=""color: #000000"">public</span> <span style=""color: #204a87; font-weight: bold"">class</span> <span style=""color: #000000"">FooMethodCall</span> <span style=""color: #000000; font-weight: bold"">{</span>     <span style=""color: #000000"">public</span> <span style=""color: #000000"">static</span> <span style=""color: #000000"">void</span> <span style=""color: #000000"">main</span><span style=""color: #000000; font-weight: bold"">(</span><span style=""color: #000000"">String</span><span style=""color: #000000; font-weight: bold"">[]</span> <span style=""color: #000000"">args</span><span style=""color: #000000; font-weight: bold"">)</span><span style=""color: #000000"">throws</span> <span style=""color: #cc0000; font-weight: bold"">Exception</span><span style=""color: #000000; font-weight: bold"">{</span>     <span style=""color: #000000"">Class</span> <span style=""color: #000000"">c</span> <span style=""color: #ce5c00; font-weight: bold"">=</span> <span style=""color: #000000"">Class</span><span style=""color: #ce5c00; font-weight: bold"">.</span><span style=""color: #000000"">forName</span><span style=""color: #000000; font-weight: bold"">(</span><span style=""color: #4e9a06"">""Foo""</span><span style=""color: #000000; font-weight: bold"">);</span>     <span style=""color: #000000"">Object</span> <span style=""color: #000000"">o</span><span style=""color: #ce5c00; font-weight: bold"">=</span> <span style=""color: #000000"">c</span><span style=""color: #ce5c00; font-weight: bold"">.</span><span style=""color: #000000"">newInstance</span><span style=""color: #000000; font-weight: bold"">();</span>     <span style=""color: #000000"">Method</span> <span style=""color: #000000"">m</span> <span style=""color: #ce5c00; font-weight: bold"">=</span><span style=""color: #000000"">c</span><span style=""color: #ce5c00; font-weight: bold"">.</span><span style=""color: #000000"">getDeclaredMethod</span><span style=""color: #000000; font-weight: bold"">(</span><span style=""color: #4e9a06"">""message""</span><span style=""color: #000000; font-weight: bold"">,</span> <span style=""color: #000000"">null</span><span style=""color: #000000; font-weight: bold"">);</span>     <span style=""color: #000000"">m</span><span style=""color: #ce5c00; font-weight: bold"">.</span><span style=""color: #000000"">setAccessible</span><span style=""color: #000000; font-weight: bold"">(</span><span style=""color: #000000"">true</span><span style=""color: #000000; font-weight: bold"">);</span>     <span style=""color: #000000"">m</span><span style=""color: #ce5c00; font-weight: bold"">.</span><span style=""color: #000000"">invoke</span><span style=""color: #000000; font-weight: bold"">(</span><span style=""color: #000000"">o</span><span style=""color: #000000; font-weight: bold"">,</span> <span style=""color: #000000"">null</span><span style=""color: #000000; font-weight: bold"">);</span>   <span style=""color: #000000; font-weight: bold"">}</span> <span style=""color: #000000; font-weight: bold"">}</span> </pre></div> </td></tr></tbody></table><!----SBAdata:eyJpc2NvbnZlcnRlZCI6ICJUcnVlIiwgImxhc3Rtb2RpZmllZCI6IDE1NTQ4Nzg3NzIsICJpZCI6ICIxNTU0ODc4NTE2NTkyLTAwMSIsICJtZCI6ICJXZSBjYW4gdXNlIFJlZmxlY3Rpb24gdG8gYWNjZXNzIHByaXZhdGUgbWV0aG9kIG9mIGEgY2xhc3MgZnJvbVxub3V0c2lkZSB0aGUgY2xhc3MuIElOIEphdmEsIHdlIHVzZSBnZXREZWNsYXJlZE1ldGhvZCgpIHRvIGdldFxuaW5zdGFuY2Ugb2YgYSBwcml2YXRlIG1ldGhvZC4gVGhlbiB3ZSBtYXJrIHRoaXMgbWV0aG9kIGFjY2Vzc2libGVcbmFuZCBmaW5hbGx5IGludm9rZSBpdC5cbkluIGZvbGxvd2luZyBzYW1wbGUgY29kZSwgd2UgYXJlIGFjY2Vzc2luZyBwcml2YXRlIG1ldGhvZFxubWVzc2FnZSgpIG9mIGNsYXNzIEZvbyBieSBSZWZsZWN0aW9uLlxuICBcbkZpbGVOYW1lOiBGb28uamF2YVxuICBcbiAgXG4gICAgcHVibGljIGNsYXNzIEZvbyB7XG4gICAgICBwcml2YXRlIHZvaWQgbWVzc2FnZSgpe1N5c3RlbS5vdXQucHJpbnRsbigmcXVvdDtoZWxsbyBqYXZhJnF1b3Q7KTsgfVxuICAgIH1cbiAgXG4gIFxuRmlsZU5hbWU6IEZvb01ldGhvZENhbGwuamF2YVxuICBcbiAgXG4gICAgaW1wb3J0IGphdmEubGFuZy5yZWZsZWN0Lk1ldGhvZDtcbiAgXG4gIFxuICAgIHB1YmxpYyBjbGFzcyBGb29NZXRob2RDYWxsIHsgIFxuICBcbiAgXG4gICAgICBwdWJsaWMgc3RhdGljIHZvaWQgbWFpbihTdHJpbmdbXSBhcmdzKXRocm93cyBFeGNlcHRpb257XG4gICAgICAgIENsYXNzIGMgPSBDbGFzcy5mb3JOYW1lKCZxdW90O0ZvbyZxdW90Oyk7XG4gICAgICAgIE9iamVjdCBvPSBjLm5ld0luc3RhbmNlKCk7XG4gICAgICAgIE1ldGhvZCBtID1jLmdldERlY2xhcmVkTWV0aG9kKCZxdW90O21lc3NhZ2UmcXVvdDssIG51bGwpO1xuICAgICAgICBtLnNldEFjY2Vzc2libGUodHJ1ZSk7XG4gICAgICAgIG0uaW52b2tlKG8sIG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgXG4ifQ==---->"
<div>99. How can we create an Object</div><div>dynamically at Runtime in Java?</div><div><br /></div>	<div>We can use Reflection to create an Object dynamically at Runtime</div><div>in &nbsp;Java. &nbsp;We &nbsp;can &nbsp;use &nbsp;Class.newInstance() &nbsp;or</div><div>Constructor.newInstance() methods for creating such Objects.</div><div>Garbage Collection</div><div><br /></div>
<div>100. What is Garbage Collection in</div><div>Java?</div><div><br /></div>	<div>Java has an internal mechanism called Garbage collection to</div><div>reclaim the memory of unused projects at run time.</div><div>Garbage collection is also known as automatic memory</div><div>management.</div><div><br /></div>
<div>101. Why Java provides Garbage</div><div>Collector?</div><div><br /></div>	<div>In Java, there are no pointers. Memory management and allocation</div><div>is done by JVM. Since memory allocation is automated, after some</div><div>time JVM may go low on memory. At that time, JVM has to free</div><div>memory from unused objects. To help with the process of</div><div>reclaiming memory, Java provides an automated process called</div><div>Garbage Collector.</div><div><br /></div>
<div>102. What is the purpose of gc() in</div><div>Java?</div><div><br /></div>	<div>Java provides two methods System.gc() and Runtime.gc() to request</div><div>the JVM to run the garbage collection. By using these methods,</div><div>programmers can explicitly send request for Garbage Collection.</div><div>But JVM process can reject this request and wait for some time</div><div>before running the GC.</div><div><br /></div>
<div>103. How does Garbage Collection</div><div>work in Java?</div><div><br /></div>	<div>Java has an automated process called Garbage Collector for</div><div>Memory Management. It is a daemon in JVM that monitors the</div><div>memory usage and performs memory cleanup. Once JVM is low on</div><div>memory, GC process finds the unused objects that are not</div><div>referenced by other objects. These unused objects are cleaned up by</div><div>Garbage Collector daemon in JVM.</div><div><br /></div>
<div>104. When does an object become</div><div>eligible for Garbage Collection in</div><div>Java?</div><div><br /></div>	<div>An object can be Garbage Collected by JVM, if it is not reachable.</div><div>There are two cases for deciding eligibility of objects for Garbage</div><div>Collection:</div><div>1. &nbsp;An Object/instance that cannot be reached by a live thread.</div><div>2. &nbsp;A set of circularly referenced instances that cannot be</div><div>reached by any other instance outside that set.</div><div><br /></div>
<div>105. Why do we use finalize() method</div><div>in Java?</div><div><br /></div>	<div>Java provides finalize() method to perform any cleanup before</div><div>Garbage Collection. This method is in Object class, and it is</div><div>invoked by JVM internally. Developers are free to implement this</div><div>method for any custom cleanup in case of Garbage Collection.</div><div>If an Object is not Garbage Collected, then this method may not be</div><div>called.</div><div>This method is never invoked more than once by JVM.</div><div><br /></div>
<div>106. What are the different types of</div><div>References in Java?</div><div><br /></div>	<div>In Java, there are four types of references:</div><div>1. &nbsp;Strong Reference</div><div>2. &nbsp;Soft Reference</div><div>3. &nbsp;Weak Reference</div><div>4. &nbsp;Phantom Reference</div><div><br /></div>
<div>107. How can we reference an</div><div>unreferenced object again?</div><div><br /></div>	<div>We can provide implementation in finalize() method to reference</div><div>and unreferenced object. For an unreferenced object, finalize()</div><div>method is called at the time of Garbage Collection. At this time,</div><div>Object can pass its reference ‘this’ to finalize() method and revive</div><div>itself.</div><div><br /></div>
<div>108. What kind of process is the</div><div>Garbage collector thread?</div><div><br /></div>	<div>Garbage Collection is a Daemon process in JVM. It is an internal</div><div>process that keep checking Memory usage and cleans up the</div><div>memory.</div><div><br /></div>
<div>109. What is the purpose of the</div><div>Runtime class?</div><div><br /></div>	<div>The purpose of the Runtime class is to provide access to the Java</div><div>Runtime system. This class provides certain important methods like:</div><div><div>1. &nbsp;Runtime.freeMemory() – This method returns the value of</div><div>free memory in JVM</div><div>2. &nbsp;Runtime.maxMemory() - This method returns the value of</div><div>maximum memory that JVM can use.</div><div>3. &nbsp;Runtime.gc() – This method can invoke garbage collection.</div></div><div><br /></div>
<div>110. How can we invoke an external</div><div>process in Java?</div><div><br /></div>	<div>Java provides the method Runtime.getRuntime().exec() to invoke an</div><div>external process from JVM.</div><div><br /></div>
<div>111. What are the uses of Runtime</div><div>class?</div><div><br /></div>	<div>Runtime class in Java provides following benefits:</div><div>1. &nbsp;It allows to read data via key board</div><div>2. &nbsp;It can use system properties and environment variables</div><div>3. &nbsp;It helps in running non-java programs from within a java</div><div>application.</div><div><br /></div>
<div>112. What is a Nested class?</div><div><br /></div>	<div>In Java, a Nested class is a class declared inside another class. We</div><div>can have more than one class declared inside a file.</div><div><br /></div>
<div>113. How many types of Nested classes</div><div>are in Java?</div><div><br /></div>	<div>Java provides four types of Nested classes:</div><div>1. &nbsp;Member inner class</div><div>2. &nbsp;Local inner class</div><div>3. &nbsp;Anonymous inner class</div><div>4. &nbsp;Static nested class</div><div><br /></div>
<div>114. Why do we use Nested Classes?</div><div><br /></div>	"<div>There are following reasons for using nested classes:</div><div>1. &nbsp;Logical Grouping: We can logically group classes in one</div><div>place. If one class is useful to only one other class, then</div><div>we put smaller class within the larger class and keep them</div><div>in one file. This kind of nesting ""helper classes"" in a top-</div><div>level class makes the package more streamlined.</div><div>2. &nbsp;Encapsulation: Nested classes increase encapsulation. Let</div><div>say there are two top-level classes, Foo and Bar. Bar</div><div>needs access to private members of Foo. We can hide</div><div>class Bar within class Foo. In this way, private members</div><div>of Foo can be accessed by class Bar. So class Foo remains</div><div>encapsulated. Also, class Bar remains hidden from the</div><div>outside world.</div><div>3. &nbsp;Code Clarity: Nested classed make the code more</div><div>readable and well organized. Only Top-level classes are</div><div>exposed. The helper classes are kept hidden and closer the</div><div>code where it is used by a Top-level class.</div><div><br /></div>"
<div>115. What is the difference between a</div><div>Nested class and an Inner class in</div><div>Java?</div><div><br /></div>	<div>An Inner class in Java is non-static class. It is a type of Nested class</div><div>that is defined in another class but not qualified with a Static</div><div>modifier. A Nested class is also a class can be Static Nested class</div><div>or a non-Static Inner class.</div><div>An Inner class has access to other members of the enclosing class,</div><div>even if they are declared private. A Static Nested class can not</div><div>access the other members of the enclosing class.</div><div><br /></div>
<div>116. What is a Nested interface?</div><div><br /></div>	<div>A Nested interface is declared inside another interface or a top-</div><div>level class. By default it is static.</div><div>A Nested interface is also known as Static interface.</div><div><br /></div>
<div>117. How can we access the non-final</div><div>local variable, inside a Local Inner</div><div>class?</div><div><br /></div>	<div>Java allows a Local Inner class to access only Constant local</div><div>members. So we have to make the non-final local variable as final</div><div>constant to access it inside a Local Inner class.</div><div><br /></div>
<div>118. Can an Interface be defined in a</div><div>Class?</div><div><br /></div>	<div>Yes, we can define a Static Nested interface within a class. Only the</div><div>enclosing class can access it.</div><div><br /></div>
<div>119. Do we have to explicitly mark a</div><div>Nested Interface public static?</div><div><br /></div>	<div>A Nested Interface is implicitly public static. So the modifiers</div><div>public and static are redundant in declaration.</div><div><br /></div>
<div>120. Why do we use Static Nested</div><div>interface in Java?</div><div><br /></div>	"<p>Only the enclosing class can access a Static Nested interface.<br /> Consider following code in which interface Xyz is enclosed in<br /> class Abc.</p> <table class=""codehilitetable""><tbody><tr><td><div class=""linenodiv"" style=""background-color: #f0f0f0; padding-right: 10px""><pre style=""line-height: 125%""> 1  2  3  4  5  6  7  8  9 10 11 12</pre></div></td><td class=""code""><div class=""codehilite"" style=""background: #f8f8f8"" align=""left""><pre style=""line-height: 125%"">public class <b>Abc</b> {     public interface Xyz {       void callback();     }     public static void registerCallback(Xyz xyz) {...} }  // Client Code Abc.registerCallback(new Abc.Xyz() {     public void callback() {...} }); </pre></div> </td></tr></tbody></table> <p>Any code that cannot access Abc can not access interface Xyz also.<br /> So the purpose of declaring an Inner interface is to restrict its<br /> access from outside world.</p><!----SBAdata:eyJpc2NvbnZlcnRlZCI6ICJUcnVlIiwgImxhc3Rtb2RpZmllZCI6IDE1NTQ4Nzk3NDUsICJpZCI6ICIxNTU0ODc5MzUyODI5LTAwMSIsICJtZCI6ICJPbmx5IHRoZSBlbmNsb3NpbmcgY2xhc3MgY2FuIGFjY2VzcyBhIFN0YXRpYyBOZXN0ZWQgaW50ZXJmYWNlLlxuQ29uc2lkZXIgZm9sbG93aW5nIGNvZGUgaW4gd2hpY2ggaW50ZXJmYWNlIFh5eiBpcyBlbmNsb3NlZCBpblxuY2xhc3MgQWJjLlxuICAgIFxuICAgIFxuICAgIHB1YmxpYyBjbGFzcyBBYmMge1xuICAgICAgICBwdWJsaWMgaW50ZXJmYWNlIFh5eiB7XG4gICAgICAgICAgdm9pZCBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgcHVibGljIHN0YXRpYyB2b2lkIHJlZ2lzdGVyQ2FsbGJhY2soWHl6IHh5eikgey4uLn1cbiAgICB9XG4gICAgXG4gICAgLy8gQ2xpZW50IENvZGVcbiAgICBBYmMucmVnaXN0ZXJDYWxsYmFjayhuZXcgQWJjLlh5eigpIHtcbiAgICAgICAgcHVibGljIHZvaWQgY2FsbGJhY2soKSB7Li4ufVxuICAgIH0pO1xuICAgIFxuQW55IGNvZGUgdGhhdCBjYW5ub3QgYWNjZXNzIEFiYyBjYW4gbm90IGFjY2VzcyBpbnRlcmZhY2UgWHl6IGFsc28uXG5TbyB0aGUgcHVycG9zZSBvZiBkZWNsYXJpbmcgYW4gSW5uZXIgaW50ZXJmYWNlIGlzIHRvIHJlc3RyaWN0IGl0c1xuYWNjZXNzIGZyb20gb3V0c2lkZSB3b3JsZC5cbiAgXG4ifQ==---->"
<div>121. What is the meaning of</div><div>Immutable in the context of String</div><div>class in Java?</div><div><br /></div>	<div>An Immutable object cannot be modified or changed in Java. String</div><div>is an Immutable class in Java.</div><div>Once a String object is created, it cannot be changed. When we</div><div>assign the String to a new value, a new object is created.</div><div><br /></div>
<div>122. Why a String object is considered</div><div>immutable in java?</div><div><br /></div>	<div>Java language uses String for a variety of purposes. For this it has</div><div>marked String Immutable.</div><div>There is a concept of String literal in Java.</div><div>Let say there are 2 String variables A and B that reference to a</div><div>String object “TestData”. All these variables refer to same String</div><div>literal. If one reference variable A changes the value of the String</div><div>literal from “TestData” to “RealData”, then it will affect the other</div><div>variable as well. Due to which String is considered Immutable. In</div><div>this case, if one variable A changes the value to “RealData”, then a</div><div>new String literal with “RealData” is created and A will point to</div><div>new String literal. While B will keep pointing to “TestData”</div><div><br /></div>
<div>123. How many objects does following</div><div>code create?</div><div><br /></div>	"<div>Code:</div><div>String s1=""HelloWorld"";</div><div>String s2="" HelloWorld "";</div><div>String s3="" HelloWorld "";</div><div>The above code creates only one object. Since there is only one</div><div>String Literal “HelloWorld” created, all the references point to</div><div>same object.</div><div><br /></div>"
<div>124. How many ways are there in</div><div>Java to create a String object?</div><div><br /></div>	<div>Java provides two ways to create a String object. One is by using</div><div>String Literal, the other is by using new operator.</div><div><br /></div>
<div>125. How many objects does</div><div>following code create?</div><div><br /></div>	"<div>Code:</div><div>String s = new String(""HelloWorld"");</div><div>The above code creates two objects. One object is created in String</div><div>constant pool and the other is created on the heap in non-pool area.</div><div><br /></div>"
<div>126. What is String interning?</div><div><br /></div>	<div>String interning refers to the concept of using only one copy of a</div><div>distinct String value that is Immutable.</div><div>It provides the advantage of making String processing efficient in</div><div>Time as well as Space complexity. But it introduces extra time in</div><div>creation of String.</div><div><br /></div>
<div>127. Why Java uses String literal</div><div>concept?</div><div><br /></div>	<div>Java uses String literal concept to make Java more efficient in</div><div>memory. If same String already exists in String constant pool, it can</div><div>be reused. This saves memory usage.</div><div><br /></div>
<div>128. What is the basic difference</div><div>between a String and StringBuffer</div><div>object?</div><div><br /></div>	<div>String is an immutable object. Its value cannot change after creation.</div><div>StringBuffer is a mutable object. We can keep appending or</div><div>modifying the contents of a StringBuffer in Java.</div><div><br /></div>
<div>129. How will you create an immutable</div><div>class in Java?</div><div><br /></div>	<div>In Java, we can declare a class final to make it immutable. There</div><div>are following detailed steps to make it Immutable:</div><div><div>1. &nbsp;Add final modifier to class to prevent it from getting</div><div>extended</div><div>2. &nbsp;Add private modifier to all the fields to prevent direct</div><div>access</div><div>3. &nbsp;Do not provide any setter methods for member variables</div><div>4. &nbsp;Add final modifier to all the mutable fields to assign value</div><div>only once</div><div>5. &nbsp;Use Deep Copy to initialize all the fields by a constructor</div><div>6. &nbsp;In clone method, return a copy of object instead of the</div><div>actual object reference</div></div><div><br /></div>
<div>130. What is the use of toString()</div><div>method in java ?</div><div><br /></div>	<div>In Java, Object class has toString() method. This method can be</div><div>used to return the String representation of an Object. When we print</div><div>an object, Java implicitly calls toString() method.</div><div>Java provides a default implementation for toString() method. But</div><div>we can override this method to return the format that we want to</div><div>print.</div><div><br /></div>
<div>131. Arrange the three classes String,</div><div>StringBuffer and StringBuilder in the</div><div>order of efficiency for String</div><div>processing operations?</div><div><br /></div>	<div>StringBuilder is the most efficient class. It does not have the</div><div>overhead of Synchronization. StringBuffer is a Synchronized class.</div><div>It has better performance than String but it is slower than</div><div>StringBuilder. String is the slowest for any String processing</div><div>operations, since it is leads to creation of new String literal with</div><div>each modification.</div><div>So the decreasing order of efficiency is: StringBuilder, StringBuffer,</div><div>String</div><div><br /></div>
<div>132. What is Exception Handling in</div><div>Java?</div><div><br /></div>	<div>Java provides Exception Handling mechanism to handle Runtime</div><div>errors that occur in JVM. There are checked exceptions in a</div><div>program that we expect to occur in certain situations.</div><div>Exception handling mechanism catches these checked exceptions</div><div>and takes relevant actions.</div><div><br /></div>
<div>133. In Java, what are the differences</div><div>between a Checked and Unchecked?</div><div><br /></div>	<div>Checked Exceptions extend Throwable class, but they do not extend</div><div>RuntimeException or Error classes. UncheckedException extend</div><div>RuntimeException class.</div><div>Checked Exceptions are checked at compile time in Java.</div><div>Unchecked Exceptions happen at Runtime, so they are not checked</div><div>at compile time.</div><div>IOException, SQLException etc. are examples of Checked</div><div>Exceptions. NullPointerException, ArithmeticException etc. are</div><div>examples of Unchecked Exceptions.</div>
<div>134. What is the base class for</div><div>Error and Exception classes in Java?</div><div><br /></div>	<div>Error as well as Exception class is derived from Throwable class</div><div>in Java.</div><div><br /></div>
<div>135. What is a finally block in Java?</div><div><br /></div>	<div>Java provides a finally block with a try block. This is an optional</div><div>block. But finally block is always executed after the execution of try</div><div>block.</div>
<div>136. What is the use of finally block in</div><div>Java?</div><div><br /></div>	<div>As per Java specification, a finally block is always executed,</div><div>whether an error occurs or not, whether an exception is handled or</div><div>not. It helps in doing the cleanup like- Rollback Transaction, Close</div><div>Connection, Close a file etc.</div><div><br /></div>
<div>137. Can we create a finally block</div><div>without creating a catch block?</div><div><br /></div>	<div>Yes. A finally block can follow a try block or catch block. So we</div><div>can defined a finally block just after a try block.</div><div><br /></div>
<div>138. Do we have to always put a catch</div><div>block after a try block?</div><div><br /></div>	<div>Java does not enforce the rule to put a catch block after try block.</div><div>We can write catch block or finally block after a try block.</div><div>Any exception that we want to catch is mentioned in catch block.</div><div><br /></div>
<div>139. In what scenarios, a finally block</div><div>will not be executed?</div><div><br /></div>	<div>There are two main scenarios in which finally block is not</div><div>executed:</div><div>1. &nbsp;Program exits by calling system.exit() call.</div><div>2. &nbsp;A fatal error causes JVM to crash.</div><div><br /></div>
<div>140. Can we re-throw an Exception</div><div>in Java?</div><div><br /></div>	<div>Yes, Java allows to re-throw an Exception.</div><div><br /></div>
<div>141. What is the difference between</div><div>throw and throws in Java?</div><div><br /></div>	<div>Java provides throw keyword to throw an exception from a method</div><div>or a static block. Java provides throws keyword to mention the</div><div>probable exception thrown by a method in its declaration.</div><div>We use throw to explicitly throw an exception. We used</div><div>throws to declare an exception in method definition.</div><div>We cannot propagate checked exceptions with throw only. But</div><div>checked exceptions can be propagated with throws keyword.</div><div>A throw call is followed by an instance. Class or Exception follows</div><div>a throws keyword.</div><div>Call to throw occurs within a method. throws is just used with</div><div>method signature.</div><div>We can throw only one exception at a time. But we can mention as</div><div>many exceptions in throws clause.</div><div><br /></div>
<div>142. What is the concept of</div><div>Exception Propagation?</div><div><br /></div>	<div>In Exception Propagation, uncaught exceptions are propagated in the</div><div>call stack until stack becomes empty. This propagation is called</div><div>Exception Propagation.</div><div>Let say an exception propagates from one method to another method.</div><div>A() calls B(), which calls C(), which calls D(). And if D() throws</div><div>an exception, the exception will propagate from D to C to B to A,</div><div>unless one of the methods catches the exception.</div><div><br /></div>
<div>143. When we override a method in</div><div>a Child class, can we throw an</div><div>additional Exception that is not</div><div>thrown by the Parent class method?</div><div><br /></div>	<div>Yes, Java allows us to throw additional Exception in a child class,</div><div>but the additional exception should be an unchecked exception</div><div>(RuntimeException).</div>
<div>144. What is the difference between</div><div>Collection and Collections</div><div>Framework in Java?</div><div><br /></div>	<div>In Java, a Collection is an object that contains multiple elements of</div><div>same type in a single unit. These multiple elements can be accessed</div><div>through one Collection object.</div><div>In Java Collections Framework is a library that provides common</div><div>architecture for creating, updating and accessing different types of</div><div>collections. In Collections framework there are common methods</div><div>that are frequently used by developers for working on a Collection</div><div>object.</div><div><br /></div>
<div>145. What are the main benefits of</div><div>Collections Framework in Java?</div><div><br /></div>	<div>Main benefits of Collections Framework in Java are as follows:</div><div>1. &nbsp;Reusability: Java Collections Framework provides</div><div>common classes and utility methods than can be used with</div><div>different types of collections. This promotes the reusability</div><div>of the code. A developer does not have to re-invent the</div><div>wheel by writing the same method again.</div><div>2. &nbsp;Quality: Using Java Collection Framework improves the</div><div>program quality, since the code is already tested and used</div><div>by thousands of developers.</div><div>3. &nbsp;Speed: Most of programmers report that their development</div><div>speed increased since they can focus on core logic and use</div><div>the generic collections provided by Java framework.</div><div>4. &nbsp;Maintenance: Since most of the Java Collections</div><div>framework code is open source and API documents is</div><div>widely available, it is easy to maintain the code written</div><div>with the help of Java Collections framework. One</div><div>developer can easily pick the code of previous developer.</div>
<div>146. What is the root interface of</div><div>Collection hierarchy in Java?</div><div><br /></div>	<div>The root interface of Collection hierarchy in Java is Collection</div><div>interface.</div><div>But the Collection interface extends Iterable interface. Due to this</div><div>some people consider Iterable interface as the root interface.</div><div>Iterable interface is present in java.lang package but Collection</div><div>interface is present in java.util package. Oracle Java API docs</div><div>mention that Collection interface is a member of the Java</div><div>Collections framework.</div><div>Whereas, Iterable interface is not stated as a part of Java</div><div>Collections framework in Java docs.</div><div>Due to this Collection interface is the root of Collections</div><div>Framework.</div>
<div>147. What are the main differences</div><div>between Collection and Collections?</div><div><br /></div>	<div>Main differences between Collection and Collections are as</div><div>follows:</div><div>1. &nbsp;Collection is an interface in Java. But Collections is a</div><div>class in Java.</div><div>2. &nbsp;Collection is a base interface. Collections is a utility class</div><div>in Java.</div><div>3. &nbsp;Collection defines methods that are used for data structures</div><div>that contain the objects. Collections defines the methods</div><div>that are used for operations like access, find etc. on a</div><div>Collection.</div><div><br /></div>
<div>148. What are the Thread-safe</div><div>classes in Java Collections</div><div>framework?</div><div><br /></div>	<div>The Thread-safe classes in Java Collections framework are:</div><div>Stack</div><div>Properties</div><div>Vector</div><div>Hashtable</div><div>BlockingQueue</div><div>ConcurrentMap</div><div>ConcurrentNavigableMap</div>
<div>149. How will you efficiently</div><div>remove elements while iterating a</div><div>Collection?</div><div><br /></div>	"<p>The right way to remove elements from a collection while iterating<br /> is by using ListIterator.remove() method.<br /> E.g.</p> <table class=""codehilitetable""><tbody><tr><td><div class=""linenodiv"" style=""background-color: #f0f0f0; padding-right: 10px""><pre style=""line-height: 125%""> 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16</pre></div></td><td class=""code""><div class=""codehilite"" style=""background: #f8f8f8"" align=""left""><pre style=""line-height: 125%"">ListIterator&lt;Integer&gt; iter = myList.iterator();   while(iter.hasNext()) {   itr.remove(); }</pre><pre style=""line-height: 125%"">//Some developers use following code to remove an element which is //incorrect:  Iterator&lt;Integer&gt; iter = myList.iterator();  while(iter.hasNext()) {   itr.remove(); } </pre></div> </td></tr></tbody></table> <p>By doing so we get ConcurrentModificationException.<br /> An iterator is first created to traverse the list. But at the same time<br /> the list is changed by remove() method.<br /> In Java, it is not allowed for a thread to modify a collection while<br /> another thread is iterating it. ListIterator provides the capability of<br /> removing an object during traversal.</p><!----SBAdata:eyJpc2NvbnZlcnRlZCI6ICJUcnVlIiwgImxhc3Rtb2RpZmllZCI6IDE1NTQ4ODAyMTAsICJpZCI6ICIxNTU0ODgwMTQ4Mzc3LTAwMSIsICJtZCI6ICJUaGUgcmlnaHQgd2F5IHRvIHJlbW92ZSBlbGVtZW50cyBmcm9tIGEgY29sbGVjdGlvbiB3aGlsZSBpdGVyYXRpbmdcbmlzIGJ5IHVzaW5nIExpc3RJdGVyYXRvci5yZW1vdmUoKSBtZXRob2QuXG5FLmcuXG4gIFxuICAgIFxuICAgIFxuICAgIExpc3RJdGVyYXRvciZsdDtJbnRlZ2VyJmd0OyBpdGVyID0gbXlMaXN0Lml0ZXJhdG9yKCk7XG4gICAgICB3aGlsZShpdGVyLmhhc05leHQoKSkge1xuICAgICAgaXRyLnJlbW92ZSgpO1xuICAgIH1cbiAgICAvL1NvbWUgZGV2ZWxvcGVycyB1c2UgZm9sbG93aW5nIGNvZGUgdG8gcmVtb3ZlIGFuIGVsZW1lbnQgd2hpY2ggaXNcbiAgICAvL2luY29ycmVjdDogIFxuICAgIFxuICAgIFxuICAgIFxuICAgIEl0ZXJhdG9yJmx0O0ludGVnZXImZ3Q7IGl0ZXIgPSBteUxpc3QuaXRlcmF0b3IoKTsgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIHdoaWxlKGl0ZXIuaGFzTmV4dCgpKSB7XG4gICAgICBpdHIucmVtb3ZlKCk7XG4gICAgfVxuICAgIFxuQnkgZG9pbmcgc28gd2UgZ2V0IENvbmN1cnJlbnRNb2RpZmljYXRpb25FeGNlcHRpb24uXG5BbiBpdGVyYXRvciBpcyBmaXJzdCBjcmVhdGVkIHRvIHRyYXZlcnNlIHRoZSBsaXN0LiBCdXQgYXQgdGhlIHNhbWUgdGltZVxudGhlIGxpc3QgaXMgY2hhbmdlZCBieSByZW1vdmUoKSBtZXRob2QuXG5JbiBKYXZhLCBpdCBpcyBub3QgYWxsb3dlZCBmb3IgYSB0aHJlYWQgdG8gbW9kaWZ5IGEgY29sbGVjdGlvbiB3aGlsZVxuYW5vdGhlciB0aHJlYWQgaXMgaXRlcmF0aW5nIGl0LiBMaXN0SXRlcmF0b3IgcHJvdmlkZXMgdGhlIGNhcGFiaWxpdHkgb2ZcbnJlbW92aW5nIGFuIG9iamVjdCBkdXJpbmcgdHJhdmVyc2FsLlxuICBcbiJ9---->"
<div>150. How will you convert a List into</div><div>an array of integers like- int[]?</div><div><br /></div>	"<p>We can use ArrayUtils class in Apache Commons Lang library.<br /> Sample code is:<br /> int[]intArray  =  ArrayUtils.toPrimitive(myList.toArray(new<br /> Integer[0]));<br /> If we use List.toArray(), it will convert List to Integer[].</p> <p>Another option is:</p> <table class=""codehilitetable""><tbody><tr><td><div class=""linenodiv"" style=""background-color: #f0f0f0; padding-right: 10px""><pre style=""line-height: 125%"">1 2 3 4 5 6</pre></div></td><td class=""code""><div class=""codehilite"" style=""background: #f8f8f8"" align=""left""><pre style=""line-height: 125%"">int[] intArray = new int[myList.size()];   for (int i=0; i &lt; myList.size(); i++) {     intArray [i] = myList.get(i); } </pre></div> </td></tr></tbody></table><!----SBAdata:eyJpc2NvbnZlcnRlZCI6ICJUcnVlIiwgImxhc3Rtb2RpZmllZCI6IDE1NTQ4ODAzODMsICJpZCI6ICIxNTU0ODgwMjY3Mjk4LTAwMSIsICJtZCI6ICJXZSBjYW4gdXNlIEFycmF5VXRpbHMgY2xhc3MgaW4gQXBhY2hlIENvbW1vbnMgTGFuZyBsaWJyYXJ5LlxuU2FtcGxlIGNvZGUgaXM6XG5pbnRbXWludEFycmF5ICA9ICBBcnJheVV0aWxzLnRvUHJpbWl0aXZlKG15TGlzdC50b0FycmF5KG5ld1xuSW50ZWdlclswXSkpO1xuSWYgd2UgdXNlIExpc3QudG9BcnJheSgpLCBpdCB3aWxsIGNvbnZlcnQgTGlzdCB0byBJbnRlZ2VyW10uXG4gIFxuQW5vdGhlciBvcHRpb24gaXM6XG4gICAgXG4gICAgXG4gICAgaW50W10gaW50QXJyYXkgPSBuZXcgaW50W215TGlzdC5zaXplKCldO1xuICAgIFxuICAgIFxuICAgIGZvciAoaW50IGk9MDsgaSAmbHQ7IG15TGlzdC5zaXplKCk7IGkrKykge1xuICAgICAgICBpbnRBcnJheSBbaV0gPSBteUxpc3QuZ2V0KGkpO1xuICAgIH1cbiAgICBcbiJ9---->"
<div>151. How will you convert an array of</div><div>primitive integers int[] to a List</div><div>collection?</div><div><br /></div>	"<p>We can use ArrayUtils in Apache Commons Lang library for this<br /> purpose.<br /> Sample code is:</p> <table class=""codehilitetable""><tbody><tr><td><div class=""linenodiv"" style=""background-color: #f0f0f0; padding-right: 10px""><pre style=""line-height: 125%"">1</pre></div></td><td class=""code""><div class=""codehilite"" style=""background: #f8f8f8"" align=""left""><pre style=""line-height: 125%"">List intList = Arrays.asList(ArrayUtils.toObject(intArray)); </pre></div> </td></tr></tbody></table> <p>The other option would be to use a for loop and explicitly adding<br /> integers to a List.</p> <p>Sample code is:</p> <table class=""codehilitetable""><tbody><tr><td><div class=""linenodiv"" style=""background-color: #f0f0f0; padding-right: 10px""><pre style=""line-height: 125%"">1 2 3 4 5 6 7 8</pre></div></td><td class=""code""><div class=""codehilite"" style=""background: #f8f8f8"" align=""left""><pre style=""line-height: 125%"">int[]intArray = {10,20,30}; List&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;();    for (int i: intArray) {   intList.add(i); } </pre></div> </td></tr></tbody></table><!----SBAdata:eyJpc2NvbnZlcnRlZCI6ICJUcnVlIiwgImxhc3Rtb2RpZmllZCI6IDE1NTQ4ODA1MDAsICJpZCI6ICIxNTU0ODgwNDAwMDM0LTAwMSIsICJtZCI6ICJXZSBjYW4gdXNlIEFycmF5VXRpbHMgaW4gQXBhY2hlIENvbW1vbnMgTGFuZyBsaWJyYXJ5IGZvciB0aGlzXG5wdXJwb3NlLlxuU2FtcGxlIGNvZGUgaXM6XG4gIFxuICAgIFxuICAgIFxuICAgIExpc3QgaW50TGlzdCA9IEFycmF5cy5hc0xpc3QoQXJyYXlVdGlscy50b09iamVjdChpbnRBcnJheSkpO1xuICAgIFxuVGhlIG90aGVyIG9wdGlvbiB3b3VsZCBiZSB0byB1c2UgYSBmb3IgbG9vcCBhbmQgZXhwbGljaXRseSBhZGRpbmdcbmludGVnZXJzIHRvIGEgTGlzdC5cbiAgXG5TYW1wbGUgY29kZSBpczpcbiAgXG4gICAgXG4gICAgXG4gICAgaW50W11pbnRBcnJheSA9IHsxMCwyMCwzMH07XG4gICAgTGlzdCZsdDtJbnRlZ2VyJmd0OyBpbnRMaXN0ID0gbmV3IEFycmF5TGlzdCZsdDtJbnRlZ2VyJmd0OygpOyAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgZm9yIChpbnQgaTogaW50QXJyYXkpIHtcbiAgICAgIGludExpc3QuYWRkKGkpO1xuICAgIH1cbiAgICBcbiJ9---->"
<div>153. How will you convert a List to a</div><div>Set?</div>	"<p>There are two ways to convert a List to a Set in Java.<br /> Option 1: Use HashSet</p> <table class=""codehilitetable""><tbody><tr><td><div class=""linenodiv"" style=""background-color: #f0f0f0; padding-right: 10px""><pre style=""line-height: 125%"">1</pre></div></td><td class=""code""><div class=""codehilite"" style=""background: #f8f8f8"" align=""left""><pre style=""line-height: 125%"">Set&lt;Integer&gt; mySet = new HashSet&lt;Integer&gt;(myList); </pre></div> </td></tr></tbody></table> <p>In this case we put a list into a HashSet. Internally hashCode()<br /> method is used to identify duplicate elements.</p> <p>Option 2: Use TreeSet<br /> In this case we use our own comparator to find duplicate objects.</p> <table class=""codehilitetable""><tbody><tr><td><div class=""linenodiv"" style=""background-color: #f0f0f0; padding-right: 10px""><pre style=""line-height: 125%"">1 2</pre></div></td><td class=""code""><div class=""codehilite"" style=""background: #f8f8f8"" align=""left""><pre style=""line-height: 125%"">Set&lt;Integer&gt; mySet = new TreeSet&lt;Integer&gt;(myComparator); mySet.addAll(myList); </pre></div> </td></tr></tbody></table><!----SBAdata:eyJpc2NvbnZlcnRlZCI6ICJUcnVlIiwgImxhc3Rtb2RpZmllZCI6IDE1NTQ4ODA4NzMsICJpZCI6ICIxNTU0ODgwODI0NTAzLTAwMSIsICJtZCI6ICJUaGVyZSBhcmUgdHdvIHdheXMgdG8gY29udmVydCBhIExpc3QgdG8gYSBTZXQgaW4gSmF2YS5cbk9wdGlvbiAxOiBVc2UgSGFzaFNldFxuICAgIFxuICAgIFxuICAgIFNldCZsdDtJbnRlZ2VyJmd0OyBteVNldCA9IG5ldyBIYXNoU2V0Jmx0O0ludGVnZXImZ3Q7KG15TGlzdCk7XG5JbiB0aGlzIGNhc2Ugd2UgcHV0IGEgbGlzdCBpbnRvIGEgSGFzaFNldC4gSW50ZXJuYWxseSBoYXNoQ29kZSgpXG5tZXRob2QgaXMgdXNlZCB0byBpZGVudGlmeSBkdXBsaWNhdGUgZWxlbWVudHMuXG4gIFxuT3B0aW9uIDI6IFVzZSBUcmVlU2V0XG5JbiB0aGlzIGNhc2Ugd2UgdXNlIG91ciBvd24gY29tcGFyYXRvciB0byBmaW5kIGR1cGxpY2F0ZSBvYmplY3RzLlxuICAgIFxuICAgIFxuICAgIFNldCZsdDtJbnRlZ2VyJmd0OyBteVNldCA9IG5ldyBUcmVlU2V0Jmx0O0ludGVnZXImZ3Q7KG15Q29tcGFyYXRvcik7XG4gICAgbXlTZXQuYWRkQWxsKG15TGlzdCk7XG4gICAgXG4ifQ==---->"
<div>154. How will you remove duplicate</div><div>elements from an ArrayList?</div><div><br /></div>	"<div>The trick in this question is to use a collection that does not allow</div><div>duplicate elements. So we use a Set for this purpose.</div><div>Option 1: Use Set</div><div>If ordering of elements is not important then we just put the elements</div><div>of ArrayList in a HashSet and then add them back to the ArrayList.</div><div><br /></div><div>Sample Code is:</div><div><br /></div><div><table><tbody><tr><td><div class=""highlight"" style=""background: #f8f8f8""><pre style=""line-height: 125%"">ArrayList myList <span style=""color: #666666"">=</span> <span style=""color: #408080; font-style: italic"">// ArrayList with duplicate elements</span> Set<span style=""color: #666666"">&lt;</span>Integer<span style=""color: #666666"">&gt;</span> mySet <span style=""color: #666666"">=</span> <span style=""color: #008000; font-weight: bold"">new</span> HashSet<span style=""color: #666666"">&lt;</span>Integer<span style=""color: #666666"">&gt;(</span>myList<span style=""color: #666666"">);</span> myList<span style=""color: #666666"">.</span><span style=""color: #7D9029"">clear</span><span style=""color: #666666"">();</span> myList<span style=""color: #666666"">.</span><span style=""color: #7D9029"">addAll</span><span style=""color: #666666"">(</span>mySet<span style=""color: #666666"">);</span> </pre></div> </td></tr></tbody></table><br /></div><div>Option 2: Use LinkedHashSet</div><div>If ordering of elements is important then we put the elements of</div><div>ArrayList in a LinkedHashSet and then add them back to the</div><div>ArrayList.</div><div><br /></div><div>Sample Code is:</div><div><br /></div><div><table><tbody><tr><td><div class=""highlight"" style=""background: #f8f8f8""><pre style=""line-height: 125%"">ArrayList myList <span style=""color: #666666"">=</span> <span style=""color: #408080; font-style: italic"">// ArrayList with duplicate elements</span> Set<span style=""color: #666666"">&lt;</span>Integer<span style=""color: #666666"">&gt;</span> mySet <span style=""color: #666666"">=</span> <span style=""color: #008000; font-weight: bold"">new</span> LinkedHashSet<span style=""color: #666666"">&lt;</span>Integer<span style=""color: #666666"">&gt;(</span>myList<span style=""color: #666666"">);</span> myList<span style=""color: #666666"">.</span><span style=""color: #7D9029"">clear</span><span style=""color: #666666"">();</span> myList<span style=""color: #666666"">.</span><span style=""color: #7D9029"">addAll</span><span style=""color: #666666"">(</span>mySet<span style=""color: #666666"">);</span> </pre></div> </td></tr></tbody></table><br /><br /></div>"
<div>155. How can you maintain a</div><div>Collection with elements in Sorted</div><div>order?</div><div><br /></div>	<div>In Java, there are many ways to maintain a Collection with elements</div><div>in sorted order.</div><div>Some collections like TreeSet store elements in the natural</div><div>ordering. In case of natural ordering we have to implement</div><div>Comparable interface for comparing the elements.</div><div>We can also maintain custom ordering by providing a custom</div><div>Comparator to a Collection.</div><div>Another option is to use the utility method Collections.sort() to sort</div><div>a List. This sorting gives nlog(n) order of performance. But if we</div><div>have to use this method multiple times then it will be costly on</div><div>performance.</div><div>Another option is to use a PriorityQueue that provides an ordered</div><div>queue. &nbsp;The &nbsp;main &nbsp;difference &nbsp;between &nbsp;PriorityQueue &nbsp;and</div><div>Collections.sort() is that PriorityQueue maintains a queue in Order</div><div>all the time, but we can only retrieve head element from queue. We</div><div>cannot access the elements of PriorityQueue in Random order.</div><div>We can use TreeSet to maintain sorted order of elements in</div><div>collection if there are no duplicate elements in collection.</div><div><br /></div>
<div>156. What are the differences between</div><div>the two data structures: a Vector and</div><div>an ArrayList?</div><div><br /></div>	<div>An ArrayList is a newer class than a Vector. A Vector is considered a</div><div>legacy class in Java. The differences are:</div><div>1. &nbsp;Synchronization: Vector is synchronized, but the ArrayList</div><div>is not synchronized. So an ArrayList has faster operations</div><div>than a Vector.</div><div>2. &nbsp;Data Growth: Internally both an ArrayList and Vector use</div><div>an array to store data. When an ArrayList is almost full it</div><div>increases its size by 50% of the array size. Whereas a</div><div>Vector increases it by doubling the underlying array size.</div><div><br /></div>
<div>157. What are the differences between</div><div>Collection and Collections in Java?</div><div><br /></div>	<div>Main differences between Collection and Collections are:</div><div>1. &nbsp;Type: Collection is an interface in Java. Collections is a</div><div>class.</div><div>2. &nbsp;Features: Collection interface provides basic features of</div><div>data structure to List, Set and Queue interfaces.</div><div>Collections is a utility class to sort and synchronize</div><div>collection elements. It has polymorphic algorithms to</div><div>operate on collections.</div><div>3. &nbsp;Method Type: Most of the methods in Collection are at</div><div>instance level. Collections class has mainly static methods</div><div>that can work on an instance of Collection.</div><div><br /></div>
<div>158. In which scenario, LinkedList</div><div>is better than ArrayList in Java?</div><div><br /></div>	<div>ArrayList is more popular than LinkedList in Java due to its ease of</div><div>use and random access to elements feature.</div><div>But LinkedList is better in the scenario when we do not need</div><div>random access to elements or there are a lot of insertion, deletion of</div><div>elements.</div><div><br /></div>
<div>159. What are the differences between</div><div>a List and Set collection in Java?</div><div><br /></div>	<div>Main differences between a List and a Set are:</div><div>1. &nbsp;Order: List collection is an ordered sequence of elements.</div><div>A Set is just a distinct collection of elements that is</div><div>unordered.</div><div>2. &nbsp;Positional Access: When we use a List, we can specify</div><div>where exactly we want to insert an element. In a Set there</div><div>is no order, so we can insert element anywhere without</div><div>worrying about order.</div><div>3. &nbsp;Duplicate: In a List we can store duplicate elements. A Set</div><div>can hold only unique elements.</div><div><br /></div>
<div>160. What are the differences between</div><div>a HashSet and TreeSet collection in</div><div>Java?</div><div><br /></div>	<div>Main differences between a HashSet and TreeSet are:</div><div>1. &nbsp;Ordering: In a HashSet elements are stored in a random</div><div>order. In a TreeSet, elements are stored according to</div><div>natural ordering.</div><div>2. &nbsp;Null Value Element: We can store null value object in a</div><div>HashSet. A TreeSet does not allow to add a null value</div><div>object.</div><div>3. &nbsp;Performance: HashSet performs basic operations like</div><div>add(), remove(), contains(), size() etc in a constant size</div><div>time. A TreeSet performs these operations at the order of</div><div>log(n) time.</div><div>4. &nbsp;Speed: A HashSet is better than a TreeSet in performance</div><div>for most of operations like add(), remove(), contains(),</div><div>size() etc .</div><div>5. &nbsp;Internal Structure: a HashMap in Java internally backs a</div><div>HashSet. A NavigableMap backs a TreeSet internally.</div><div>6. &nbsp;Features: A TreeSet has more features compared to a</div><div>HashSet. It has methods like pollFirst(), pollLast(), first(),</div><div>last(), ceiling(), lower() etc.</div><div>7. &nbsp;Element Comparison: A HashSet uses equals() method for</div><div>comparison. A TreeSet uses compareTo() method for</div><div>comparison to maintain ordering of elements.</div>
<div>161. In Java, how will you decide when</div><div>to use a List, Set or a Map collection?</div><div><br /></div>	<div>1. &nbsp;If we want a Collection that does not store duplicate</div><div>values, then we use a Set based collection.</div><div>2. &nbsp;If we want to frequently access elements operations based</div><div>on an index value then we use a List based collection. E.g.</div><div>ArrayList</div><div>3. &nbsp;If we want to maintain the insertion order of elements in a</div><div>collection then we use a List based collection.</div><div>4. &nbsp;For fast search operation based on a key, value pair, we</div><div>use a HashMap based collection.</div><div>5. &nbsp;If we want to maintain the elements in a sorted order, then</div><div>we use a TreeSet based collection.</div><div><br /></div>
<div>162. What are the differences between</div><div>a HashMap and a Hashtable in Java?</div><div><br /></div>	<div>Main differences between a HashMap and a Hashtable are:</div><div>1. &nbsp;Synchronization: &nbsp;HashMap &nbsp;is &nbsp;not &nbsp;a &nbsp;synchronized</div><div>collection. If it is used in multi-thread environment, it may</div><div>not provide thread safety. A Hashtable is a synchronized</div><div>collection. Not more than one thread can access a</div><div>Hashtable at a given moment of time. The thread that</div><div>works on Hashtable acquires a lock on it and it makes</div><div>other threads wait till its work is completed.</div><div>2. &nbsp;Null values: A HashMap allows only one null key and any</div><div>number of null values. A Hashtable does not allow null</div><div>keys and null values.</div><div>3. &nbsp;Ordering: A HashMap implementation by LinkedHashMap</div><div>maintains the insertion order of elements. A TreeMap sorts</div><div>the mappings based on the ascending order of keys. On the</div><div>other hand, a Hashtable does not provide guarantee of any</div><div>kind of order of elements. It does not maintain the</div><div>mappings of key values in any specific order.</div><div>4. &nbsp;Legacy: Hashtable was not the initial part of collection</div><div>framework in Java. It has been made a collection</div><div>framework member, after being retrofitted to implement the</div><div>Map interface. A HashMap implements Map interface and</div><div>is a part of collection framework since the beginning.</div><div>5. &nbsp;Iterator: The Iterator of HashMap is a fail-fast and it</div><div>throws ConcurrentModificationException if any other</div><div>Thread modifies the map by inserting or removing any</div><div>element &nbsp;except &nbsp;iterator’s &nbsp;own &nbsp;remove() &nbsp;method.</div><div>Enumerator of the Hashtable is not fail-fast.</div><div><br /></div>
<div>163. What are the differences between</div><div>a HashMap and a TreeMap?</div><div><br /></div>	<div>Main differences between a HashMap and a TreeMap in Java are:</div><div>1. &nbsp;Order: A HashMap does not maintain any order of its keys.</div><div>In a HashMap there is no guarantee that the element</div><div>inserted first will be retrieved first.</div><div>2. &nbsp;In a TreeMap elements are stored according to natural</div><div>ordering of elements. A TreeMap uses compareTo()</div><div>method to store elements in a natural order.</div><div>3. &nbsp;Internal Implementation: A HashMap uses Hashing</div><div>internally. A TreeMap internally uses Red-Black tree</div><div>implementation.</div><div>4. &nbsp;Parent Interfaces: A HashMap implements Map interface.</div><div>TreeMap implements NavigableMap interface.</div><div>5. &nbsp;Null values: A HashMap can store one null key and</div><div>multiple null values. A TreeMap can not contain null key</div><div>but it may contain multiple null values.</div><div>6. &nbsp;Performance: A HashMap gives constant time performance</div><div>for operations like get() and put(). A TreeMap gives order</div><div>of log(n) time performance for get() and put() methods.</div><div>7. &nbsp;Comparison: A HashMap uses equals() method to compare</div><div>keys. A TreeMap uses compareTo() method for</div><div>maintaining natural ordering.</div><div>8. &nbsp;Features: A TreeMap has more features than a HashMap. It</div><div>has methods like pollFirstEntry() , pollLastEntry() ,</div><div>tailMap() , firstKey() , lastKey() etc. that are not provided</div><div>by a HashMap.</div><div><br /></div>
<div>164. What are the differences</div><div>between Comparable and</div><div>Comparator?</div><div><br /></div>	"<div>Main differences between Comparable and Comparator are:</div><div>1. &nbsp;Type: Comparable&lt;T&gt; is an interface in Java where T is</div><div>the type of objects that this object may be compared to.</div><div>2. &nbsp;Comparator&lt;T&gt; is also an interface where T is the type of</div><div>objects that may be compared by this comparator.</div><div>3. &nbsp;Sorting: In Comparable, we can only create one sort</div><div>sequence. In Comparator we can create multiple sort</div><div>sequences.</div><div>4. &nbsp;Method Used: Comparator&lt;T&gt; interface in Java has</div><div>method public int compare (Object o1, Object o2) that</div><div>returns a negative integer, zero, or a positive integer when</div><div>the object o1 is less than, equal to, or greater than the</div><div>object o2. A Comparable&lt;T&gt; interface has method public</div><div>int compareTo(Object o) that returns a negative integer,</div><div>zero, or a positive integer when this object is less than,</div><div>equal to, or greater than the object o.</div><div>5. &nbsp;Objects for Comparison: The Comparator compares two</div><div>objects given to it as input. Comparable interface</div><div>compares ""this"" reference with the object given as input.</div><div>6. &nbsp;Package location: Comparable interface in Java is defined</div><div>in java.lang package. Comparator interface in Java is</div><div>defined in java.util package.</div><div><br /></div>"
<div>165. In Java, what is the purpose of</div><div>Properties file?</div><div><br /></div>	<div>A Properties file in Java is a list of key-value pairs that can be</div><div>parsed by java.util.Properties class.</div><div>Generally a Properties file has extension .properties e.g.</div><div>myapp.properties.</div><div>Properties files are used for many purposes in all kinds of Java</div><div>applications. Some of the uses are to store configuration, initial</div><div>data, application options etc.</div><div>When we change the value of a key in a properties file, there is no</div><div>need to recompile the Java application. So it provides benefit of</div><div>changing values at runtime.</div><div><br /></div>
<div>166. What is the reason for overriding</div><div>equals() method?</div><div><br /></div>	<div>The equals() method in Object class is used to check whether two</div><div>objects are same or not. If we want a custom implementation we can</div><div>override this method.</div><div>For example, a Person class has first name, last name and age. If we</div><div>want two Person objects to be equal based on name and age, then</div><div>we can override equals() method to compare the first name, last</div><div>name and age of Person objects.</div><div>Generally in HashMap implementation, if we want to use an object</div><div>as key, then we override equals() method.</div><div><br /></div>
<div>167. How does hashCode() method</div><div>work in Java?</div><div><br /></div>	<div>Object class in Java has hashCode() method. This method returns a</div><div>hash code value, which is an integer.</div><div>The hashCode() is a native method and its implementation is not</div><div>pure Java.</div><div>Java doesn't generate hashCode(). However, Object generates a</div><div>HashCode based on the memory address of the instance of the</div><div>object.</div><div>If two objects are same then their hashCode() is also same.</div><div><br /></div>
<div>168. Is it a good idea to use Generics</div><div>in collections?</div><div><br /></div>	<div>Yes. A collection is a group of elements put together in an order or</div><div>based on a property. Often the type of element can vary. But the</div><div>properties and behavior of a Collection remains same. Therefore it</div><div>is good to create a Collection with Generics so that it is type-safe</div><div>and it can be used with wide variety of elements.</div><div><br /></div>
<div>169. What is the difference between</div><div>Collections.emptyList() and creating</div><div>new instance of Collection?</div><div><br /></div>	<div>In &nbsp;both &nbsp;the &nbsp;approaches, &nbsp;we &nbsp;get &nbsp;an &nbsp;empty &nbsp;list. &nbsp;But</div><div>Collections.emptyList() returns an Immutable list. We cannot add</div><div>new elements to an Immutable empty list.</div><div>Collections.emptyList() works like Singleton pattern. It does not</div><div>create a new instance of List. It reuses an existing empty list</div><div>instance.</div><div>Therefore, Collections.emptylist() gives better performance if we</div><div>need to get an emptyList multiple times.</div><div><br /></div>
<div>170. How will you copy elements from</div><div>a Source List to another list?</div><div><br /></div>	"<div>There are two options to copy a Source List to another list.</div><div><br /></div><div>Option 1: Use ArrayList constructor</div><div><pre class=""myCodeClass"">ArrayList&lt;Integer&gt; newList = new ArrayList&lt;Integer&gt;(sourceList);</pre></div><div>Option 2: Use Collection.copy()</div><div><br /></div><div>To use Collections.copy() destination list should be of same or</div><div>larger size than source list.</div><div><br /></div><div><table><tbody><tr><td><div class=""highlight"" style=""background: #f8f8f8""><pre style=""line-height: 125%"">ArrayList<span style=""color: #666666"">&lt;</span>Integer<span style=""color: #666666"">&gt;</span>  newList  <span style=""color: #666666"">=</span>  <span style=""color: #008000; font-weight: bold"">new</span>  ArrayList<span style=""color: #666666"">&lt;</span>Integer<span style=""color: #666666"">&gt;</span> <span style=""color: #666666"">(</span>sourceList<span style=""color: #666666"">.</span><span style=""color: #7D9029"">size</span><span style=""color: #666666"">());</span> Collections<span style=""color: #666666"">.</span><span style=""color: #7D9029"">copy</span><span style=""color: #666666"">(</span>newList<span style=""color: #666666"">,</span> sourceList<span style=""color: #666666"">);</span> </pre></div> </td></tr></tbody></table><br /></div><div>Collections.copy() does not reallocate the capacity of destination</div><div>List if it does not have enough space to contain all elements of</div><div>source List. It throws IndexOutOfBoundsException.</div><div>The benefit of Collection.copy() is that it guarantees that the copy</div><div>will happen in linear time. It is also good for the scenario when we</div><div>want to reuse an array instead of allocating more memory in the</div><div>constructor of ArrayList.</div><div>One limitation of Collections.copy() is that it can accept only List</div><div>as source and destination parameters.</div><div><br /></div>"
<div>171. What are the Java Collection</div><div>classes that implement List interface?</div><div><br /></div>	<div>Java classes that implement List interface are:</div><div>AbstractList</div><div>AbstractSequentialList</div><div>ArrayList</div><div>AttributeList</div><div>CopyOnWriteArrayList</div><div>LinkedList</div><div>RoleList</div><div>RoleUnresolvedList</div><div>Stack</div><div>Vector</div><div><br /></div>
<div>172. What are the Java Collection</div><div>classes that implement Set interface?</div><div><br /></div>	<div>Java classes that implement Set interface are:</div><div>AbstractSet</div><div>ConcurrentSkipListSet</div><div>CopyOnWriteArraySet</div><div>EnumSet</div><div>HashSet</div><div>JobStateReasons</div><div>LinkedHashSet</div><div>TreeSet</div><div><br /></div>
<div>173. What is the difference between an</div><div>Iterator and ListIterator in Java?</div><div><br /></div>	<div>Iterator and ListIterator are two interfaces in Java to traverse data</div><div>structures. The differences between these two are:</div><div>1. &nbsp;ListIterator can be used to traverse only a List. But Iterator</div><div>can be used to traverse List, Set, and Queue etc.</div><div>2. &nbsp;An Iterator traverses the elements in one direction only. It</div><div>just goes. ListIterator can traverse the elements in two</div><div>directions i.e. backward as well as forward directions.</div><div>3. &nbsp;Iterator cannot provide us index of an element in the Data</div><div>Structure. ListIterator provides us methods like nextIndex()</div><div>and previousIndex() to get the index of an element during</div><div>traversal.</div><div>4. &nbsp;Iterator does not allow us to add an element to collection</div><div>while &nbsp;traversing &nbsp;it. &nbsp;It &nbsp;throws</div><div>ConcurrentModificationException. ListIterator allows use</div><div>to add an element at any point of time while traversing a</div><div>list.</div><div>5. &nbsp;An existing element’s value cannot be replaced by using</div><div>Iterator. ListIterator provides the method set(e) to replace</div><div>the value of last element returned by next() or previous()</div><div>methods.</div><div><br /></div>
<div>174. What is the difference between</div><div>Iterator and Enumeration?</div><div><br /></div>	<div>Both Iterator and Enumeration are interfaces in Java to access Data</div><div>Structures. The main differences between these are:</div><div>1. &nbsp;Enumeration is an older interface. Iterator is a newer</div><div>interface.</div><div>2. &nbsp;Enumeration can only traverse legacy collections. Iterator</div><div>can traverse both legacy as well as newer collections.</div><div>3. &nbsp;Enumeration does not provide remove() method. So we</div><div>cannot remove any element during traversal. Iterator</div><div>provides remove() method.</div><div>4. &nbsp;Iterator &nbsp;is &nbsp;a &nbsp;fail-fast &nbsp;interface, &nbsp;it &nbsp;gives</div><div>ConcurrentModificationException if any thread tries to</div><div>modify an element in the collection being iterated.</div><div>Enumeration is not fail-fast.</div><div>5. &nbsp;Method names in Iterator are shorter than in an</div><div>Enumeration.</div><div><br /></div>
<div>175. What is the difference between an</div><div>ArrayList and a LinkedList data</div><div>structure?</div><div><br /></div>	<div>Main differences between ArrayList and LinkedList data structures</div><div>are:</div><div>1. &nbsp;Data Structure: An ArrayList is an indexed based</div><div>dynamic array. A LinkedList is a Doubly Linked List data</div><div>structure.</div><div>2. &nbsp;Insertion: It is easier to insert new elements in a</div><div>LinkedList, since there is no need to resize an array.</div><div>Insertion in ArrayList is O(n), since it may require resizing</div><div>of array and copying its contents to new array.</div><div>3. &nbsp;Remove elements: LinkedList has better performance in</div><div>removal of elements than ArrayList.</div><div>4. &nbsp;Memory Usage: LinkedList uses more memory than</div><div>ArrayList, since it has to maintain links for next and</div><div>previous nodes as well.</div><div>5. &nbsp;Access: LinkedList is slower in accessing an element,</div><div>since we have to traverse the list one by one to access the</div><div>right location.</div><div><br /></div>
<div>176. What is the difference between a</div><div>Set and a Map in Java?</div><div><br /></div>	<div>Main differences between a Set and a Map in Java are:</div><div>1. &nbsp;Duplicate Elements: A Set does not allow inserting</div><div>duplicate elements. A Map does not allow using duplicate</div><div>keys, but it allows inserting duplicate values for unique</div><div>keys.</div><div>2. &nbsp;Null values: A Set allows inserting maximum one null</div><div>value. In a Map we can have single null key at most and</div><div>any number of null values.</div><div>3. &nbsp;Ordering: A Set does not maintain any order of elements.</div><div>Some of sub-classes of a Set can sort the elements in an</div><div>order like LinkedHashSet. A Map does not maintain any</div><div>order of its elements. Some of its sub-classes like</div><div>TreeMap store elements of the map in ascending order of</div><div>keys.</div><div><br /></div>
<div>177. What is the use of a Dictionary</div><div>class?</div><div><br /></div>	<div>The Dictionary class in Java is used to store key-value pairs. Any</div><div>non-null object can be used for key or value. But we cannot insert a</div><div>null key or null object in Dictionary.</div><div>Dictionary class is deprecated now. So it should not be used in</div><div>newer implementations.</div>
<div>178. What is the default size of load</div><div>factor in a HashMap collection in</div><div>Java?</div><div><br /></div>	<div>Default value of load factor in a HashMap is 0.75.</div>
<div>179. What is the significance of load</div><div>factor in a HashMap in Java?</div><div><br /></div>	<div>A HashMap in Java has default initial capacity 16 and the load</div><div>factor is 0.75f (i.e. 75% of current map size). The load factor of a</div><div>HashMap is the level at which its capacity should be doubled.</div><div>For example, in a HashMap of capacity 16 and load factor .75. The</div><div>capacity will become 32 when the HashMap is 75% full. Therefore,</div><div>after storing the 12th key– value pair (16 * .75 = 12) into HashMap,</div><div>its capacity becomes 32.</div><div><br /></div>
<div>180. What are the major differences</div><div>between a HashSet and a HashMap?</div><div><br /></div>	<div>The main difference between a HashSet and a HashMap are:</div><div>1. &nbsp;Base class: A HashSet class implements the Set interface.</div><div>Whereas a HashMap class implements the Map interface.</div><div>2. &nbsp;Storage: A HashSet is used to store distinct objects. A</div><div>HashMap is used for storing key &amp; value pairs, so that</div><div>these can be retrieved by key later on.</div><div>3. &nbsp;Duplicate Elements: A HashSet does not allow storing</div><div>duplicate elements. A HashMap also does not allow</div><div>duplicate keys. But we can store duplicate values in a</div><div>HashMap.</div><div>4. &nbsp;Null Elements: In a HashSet we can store a single null</div><div>value. In a HashMap we can store single null key, but any</div><div>number of null values.</div><div>5. &nbsp;Element Type: A HashSet contains only values of objects</div><div>as its elements. Whereas a HashMap contains entries(key</div><div>value pairs).</div><div>6. &nbsp;Iteration: By using an Iterator we can iterate a HashSet.</div><div>But a HashMap has to be converted into Set for iteration.</div><div><br /></div>
<div>181. What are the similarities between</div><div>a HashSet and a HashMap in Java?</div><div><br /></div>	<div>As the name suggests, HashSet and HashMap are Hashing based</div><div>collections. Similarities between HashSet and HashMap are:</div><div>1. &nbsp;Thread Safety: Both HashMap and HashSet are not</div><div>synchronized collections. Therefore they are not good for</div><div>thread-safe operations. To make these thread-safe we need</div><div>to explicitly use synchronized versions.</div><div>2. &nbsp;Order of Elements: None of these classes guarantee the</div><div>order of elements. These are unordered collections.</div><div>3. &nbsp;Internal Implementation: A HashMap backs up a HashSet</div><div>internally. So HashSet uses a HashMap for performing its</div><div>operations.</div><div>4. &nbsp;Performance: Both of these collections provide constant</div><div>time performance for basic operations such as insertion</div><div>and removal of elements.</div><div><br /></div>
<div>182. What is the reason for</div><div>overriding equals() method?</div><div><br /></div>	<div>The equals() method in Object class is used to check whether two</div><div>objects are same or not. If we want a custom implementation we can</div><div>override this method.</div><div>For example, a Person class has first name, last name and age. If we</div><div>want two Person objects to be equal based on name and age, then</div><div>we can override equals() method to compare the first name, last</div><div>name and age of Person objects.</div><div>Generally in HashMap implementation, if we want to use an object</div><div>as key, then we override equals() method.</div><div><br /></div>
<div>183. How can we synchronize the</div><div>elements of a List, a Set or a Map?</div><div><br /></div>	"<div>Sometimes we need to make collections Thread-safe for use in</div><div>Multi-threading environment. In Java, Collections class provides</div><div>useful static methods to make a List, Set or Map as synchronized</div><div>collections. Some of these methods are:</div><div><pre class=""myCodeClass"">static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt;&nbsp;c)</pre></div><div>Returns a synchronized (thread-safe) collection backed by the</div><div>specified collection.</div><div><br /></div><div><pre class=""myCodeClass"">static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</pre></div><div>Returns a synchronized (thread-safe) list backed by the specified</div><div>list.</div><div><br /></div><div><pre class=""myCodeClass"">static &lt;K,V&gt; Map&lt;K,V&gt;synchronizedMap(Map&lt;K,V&gt; m)</pre></div><div>Returns a synchronized (thread-safe) map backed by the specified</div><div>map.</div><div><br /></div><div><pre class=""myCodeClass"">static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s)</pre></div><div>Returns a synchronized (thread-safe) set backed by the specified</div><div>set.</div><div><br /></div><div><pre class=""myCodeClass"">static &nbsp;&lt;K,V&gt;&nbsp;SortedMap&lt;K,V&gt; synchronizedSortedMap(SortedMap&lt;K,V&gt; m)</pre></div><div>Returns a synchronized (thread-safe) sorted map backed by the</div><div>specified sorted map.</div><div><br /></div><div><pre class=""myCodeClass"">static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s)</pre></div><div>Returns a synchronized (thread-safe) sorted set backed by the</div><div>specified sorted set.</div><div><br /></div>"
<div>184. What is Hash Collision? How</div><div>Java handles hash-collision in</div><div>HashMap?</div><div><br /></div>	<div>In a Hashing scenario, at times two different objects may have same</div><div>HashCode but they may not be equal. Therefore, Java will face</div><div>issue while storing the two different objects with same HashCode in</div><div>a HashMap. This kind of situation is Hash Collision.</div><div>There are different techniques of resolving or avoiding Hash</div><div>Collision. But in HashMap, Java simply replaces the Object at old</div><div>Key with new Object in case of Hash Collision.</div><div><br /></div>
<div>185. What are the Hash Collision</div><div>resolution techniques?</div><div><br /></div>	<div>To resolve a Hash Collision we can use one of the following</div><div>techniques:</div><div>Separate Chaining with Linked List</div><div>Separate Chaining with List Head Cells</div><div>Open Addressing with Coalesced Hashing</div><div>Open Addressing with Cuckoo Hashing</div><div>Hopscotch Hashing</div><div>Robinhood Hashing</div><div><br /></div>
<div>186. What is the difference between</div><div>Queue and Stack data structures?</div><div><br /></div>	<div>Queue is a FIFO data structure. FIFO stands for First In First Out. It</div><div>means the element added first will be removed first from the queue.</div><div>A real world example of Queue is a line for buying tickets at a</div><div>station. The person entering first in the Queue is served first.</div><div>Stack is a LIFO data structure. LIFO stands for Last In First Out.</div><div>The element that is added last is removed first from the collection.</div><div>In a Stack elements are added or removed from the top of stack.</div><div>A real world example of Stack is back button in browser. We can go</div><div>back one by one only and it works in the reverse order of adding</div><div>webpages to history .</div><div><br /></div>
<div>187. What is an Iterator in Java?</div><div><br /></div>	<div>Iterator is an interface in Java to access the elements in a collection.</div><div>It is in java.util package.</div><div>It provides methods to iterate over a Collection class in Java.</div><div>Iterator interface in Java is based on Iterator design pattern. By</div><div>using an Iterator one can traverse a container of objects and can</div><div>also access the objects in the container. A container of objects is a</div><div>Collection class in Java.</div>
<div>188. What is the difference between</div><div>Iterator and Enumeration in Java?</div><div><br /></div>	<div>Main differences between Iterator and Enumeration in Java are:</div><div>1. &nbsp;Version: Enumeration interface is in Java since JDK 1.0.</div><div>Iterator interface was introduced in Java 1.2.</div><div>2. &nbsp;remove() &nbsp;method: &nbsp;The &nbsp;main &nbsp;difference &nbsp;between</div><div>Enumeration and Iterator interface is remove() method.</div><div>Enumeration can just traverse a Collection object. If we</div><div>use Enumeration, we cannot do any modifications to a</div><div>Collection while traversing the collection. Iterator</div><div>interface provides remove() method to remove an element</div><div>while traversing the Collection. There is not remove()</div><div>method in Enumeration interface.</div><div>3. &nbsp;Method names: Names of methods in Iterator interface are</div><div>hasNext(), next(), remove(). Names of methods in</div><div>Enumeration &nbsp;interface &nbsp;are &nbsp;hasMoreElements(),</div><div>nextElement().</div><div>4. &nbsp;Legacy Interface: Enumeration is considered as a legacy</div><div>interface. It is used to traverse legacy classes like Vector,</div><div>Stack and HashTable. Iterator is a newer interface that is</div><div>used to traverse almost all of the classes in Java</div><div>Collections framework.</div><div>5. &nbsp;Fail-fast vs. Fail-safe: Iterator is based on fail-fast</div><div>principle. It throws ConcurrentModificationException if a</div><div>collection is modified during iteration over that collection.</div><div>An Enumeration is based on fail-safe principle. It doesn’t</div><div>throw any exception if a collection is modified during</div><div>traversal.</div><div>6. &nbsp;Safety: Since Iterator is fail-fast and does not allow</div><div>modification of a collection by other threads, it is</div><div>considered safer than Enumeration.</div><div><br /></div>
<div>189. What is the design pattern</div><div>used in the implementation of</div><div>Enumeration in Java?</div><div><br /></div>	<div>Enumeration is based on Iterator design pattern. Iterator design</div><div>pattern provides a common interface with methods to traverse the</div><div>collection of objects. It hides the underlying implementation details</div><div>of the collection.</div><div><br /></div>
<div>190. Which methods do we need to</div><div>override to use an object as key in a</div><div>HashMap?</div><div><br /></div>	<div>If we want to use an object as a key in a HashMap in Java, then we</div><div>have to make sure that it has the implementation of equals() and</div><div>hashCode() methods.</div><div><br /></div>
<div>191. How will you reverse a List in</div><div>Java?</div><div><br /></div>	"<div>In Collections class, Java provides a method reverse(List list) that</div><div>can be used to reverse a List.</div><div>E.g.</div><div><pre class=""myCodeClass"">Collections.reverse(myList);</pre></div>"
<div>192. How will you convert an array of</div><div>String objects into a List?</div><div><br /></div>	"<div>Java provides Arrays class in java.util package. Arrays class has a</div><div>method asList() that accepts an Array as input and returns a List as</div><div>output.</div><div><pre class=""myCodeClass"">public static &lt;T&gt; List&lt;T&gt; asList(T... a) String[] myArray = {""George"" , ""Jack"" , ""Ryan""}; List myList = Arrays.asList(myArray); </pre></div>"
<div>193. What is the difference between</div><div>peek(), poll() and remove() methods of</div><div>Queue interface in java?</div><div><br /></div>	<div>In a Java Queue, poll() and remove() methods can be used for</div><div>removing the head object of Queue. The main difference arises in</div><div>the case when Queue is empty().</div><div>If Queue is empty then poll() method returns null value. If Queue is</div><div>empty then remove() method throws NoSuchElementException.</div><div>In a Java Queue, peek() method retrieves the head of Queue but it</div><div>does not remove it. If queue is empty then peek() method returns</div><div>null value.</div><div><br /></div>
<div>194. What is the difference between</div><div>Array and ArrayList in Java?</div><div><br /></div>	<div>The main differences between Array and ArrayList in Java are:</div><div>1. &nbsp;Size: Array in Java is fixed in size. We cannot change the</div><div>size of array after creating it. ArrayList is dynamic in size.</div><div>When we add elements to an ArrayList, its capacity</div><div>increases automatically.</div><div>2. &nbsp;Performance: In Java Array and ArrayList give different</div><div>performance for different operations.</div><div>3. &nbsp;add() or get(): Adding an element to or retrieving an</div><div>element from an array or ArrayList object has similar</div><div>performance. These are constant time operations.</div><div>4. &nbsp;resize(): Automatic resize of ArrayList slows down the</div><div>performance. ArrayList is internally backed by an Array.</div><div>In resize() a temporary array is used to copy elements from</div><div>old array to new array.</div><div>5. &nbsp;Primitives: Array can contain both primitive data types as</div><div>well as objects. But ArrayList cannot contain primitive</div><div>data types. It contains only objects.</div><div>6. &nbsp;Iterator: In an ArrayList we use an Iterator object to</div><div>traverse the elements. We use for loop for iterating</div><div>elements in an array.</div><div>7. &nbsp;Type Safety: Java helps in ensuring Type Safety of</div><div>elements in an ArrayList by using Generics. An Array can</div><div>contain objects of same type of class. If we try to store a</div><div>different data type object in an Array then it throws</div><div>ArrayStoreException.</div><div>8. &nbsp;Length: Size of ArrayList can be obtained by using size()</div><div>method. Every array object has length variable that is same</div><div>as the length/size of the array.</div><div>9. &nbsp;Adding elements: In an ArrayList we can use add()</div><div>method to add objects. In an Array assignment operator is</div><div>used for adding elements.</div><div>10. &nbsp;Multi-dimension: An Array can be multi-dimensional. An</div><div>ArrayList is always of single dimension.</div><div><br /></div>
<div>195. How will you insert, delete and</div><div>retrieve elements from a HashMap</div><div>collection in Java?</div><div><br /></div>	<div>We use following methods to insert, delete and retrieve elements in</div><div>a HashMap.</div><div>1. &nbsp;Retrieve: We use get() method to retrieve elements from a</div><div>HashMap.</div><div>Value get(Object key)</div><div>2. &nbsp;Insert: We use put() method to insert a key value pair in a</div><div>HashMap.</div><div>Value put(Key k, Value v)</div><div>3. &nbsp;Delete: We use remove() method to delete key-value pair</div><div>from the HashMap.</div><div>Value remove(Object key)</div><div><br /></div>
<div>196. What are the main differences</div><div>between HashMap and</div><div>ConcurrentHashMap in Java?</div><div><br /></div>	<div>Main differences between HashMap and ConcurrentHashMap are:</div><div>1. &nbsp;Synchronization: A HashMap is not synchronized. But a</div><div>ConcurrentHashMap is a synchronized object.</div><div>2. &nbsp;Null Key: A HashMap can have one null key and any</div><div>number of null values. A ConcurrentHashMap cannot have</div><div>null keys or null values.</div><div>3. &nbsp;Multi-threading: A ConcurrentHashMap works well in a</div><div>multi-threading environment.</div><div><br /></div>
<div>197. What is the increasing order of</div><div>performance for following collection</div><div>classes in Java?</div>	<div>The increasing order of performance is:</div><div>Hashtable</div><div>Collections.SynchronizedMap</div><div>ConcurrentHashMap</div><div>HashMap</div><div>Hashtable has the worst performance and HashMap has the best</div><div>performance.</div><div><br /></div>
<div>198. Why does Map interface not</div><div>extend Collection interface in Java?</div><div><br /></div>	<div>A Map is a collection objects. But Map interface is not compatible</div><div>with Collection interface in Java.</div><div>A Map requires key as well as a value. So it requires two</div><div>parameters to add an element to a HashMap.</div><div>But Collection interface provides add(Object o) method with only</div><div>one parameter.</div><div>Map collection has to provide methods like valueSet, keySet etc.</div><div>These methods are specific to Map collection. Where as methods in</div><div>Collection interface can be reused by a List, Set, Queue etc.</div><div><br /></div>
<div>199. What are the different ways to</div><div>iterate elements of a list in Java?</div>	<div>There are mainly two ways to iterate the elements of list in Java:</div><div>1. &nbsp;Iterator: We can get an Iterator for list and use it to iterate</div><div>the objects of the list.</div><div>2. &nbsp;For-each loop: We can use for-each loop to traverse all</div><div>the elements of a list.</div>
<div>200. What is</div><div>CopyOnWriteArrayList? How it is</div><div>different from ArrayList in Java?</div>	<div>CopyOnWriteArrayList was introduced in Java 5 version. It is a</div><div>thread-safe collection. It is similar to an ArrayList.</div><div>In CopyOnWriteArrayList, all mutative operations (add, set etc.)</div><div>are implemented by making a fresh copy of the underlying array.</div><div>Iterator of CopyOnWriteArrayList is guaranteed to not throw</div><div>ConcurrentModificationException. But Iterator also does not reflect</div><div>any additions, removals that happened to list after the Iterator was</div><div>created.</div><div>All elements including null are permitted in CopyOnWriteArrayList.</div>
<div>201. How remove() method is</div><div>implemented in a HashMap?</div>	<div>Remove() method in HashMap uses logic similar to the one used in</div><div>get() method. First we locate the correct bucket in HashMap for an</div><div>entry. Then within that bucket we remove the element e. It is similar</div><div>to removing a node from a single-linked list.</div><div>If e is the first element in the bucket we set the corresponding</div><div>element of Hash to e.next. Else we set the next field of the element</div><div>just before e to e.next.</div>
<div>202. What is BlockingQueue in</div><div>Java Collections?</div><div><br /></div>	"<div>BlockingQueue was introduced in Java 1.5. It extends Queue</div><div>interface in Java.</div><div>BlockingQueue supports operations that wait for the queue to</div><div>become non-empty when retrieving an element. Also it supports the</div><div>operations that wait for space to become available in the queue</div><div>while storing an element.</div><div>Some of the features of BlockingQueue are:</div><div>It does not accept null elements.</div><div>Its main use is in producer-consumer problems.</div><div>BlockingQueue implementation is thread-safe.</div><div>It can be used in inter-thread communications.</div><div>It does not support any kind of ""close"" or ""shutdown""</div><div>operation to indicate that no more items will be added.</div>"
<div>203. How is TreeMap class</div><div>implemented in Java?</div><div><br /></div>	<div>Internally, a TreeMap class in Java uses Red-Black tree.</div><div>It is a NavigableMap. The map sorts the keys in natural order or it</div><div>can use a Comparator supplied at the creation time.</div><div>The implementation of TreeMap is not synchronized in Java.</div>
<div>204. What is the difference between</div><div>Fail-fast and Fail-safe iterator in</div><div>Java?</div><div><br /></div>	<div>Differences between Fail-fast and Fail-safe iterators are as</div><div>follows:</div><div>Fail-fast iterator throws ConcurrentModificationException. But</div><div>Fail-safe iterator does not throw this exception.</div><div>Fail-fast iterator does not clone the original collection. Fail-safe</div><div>iterator creates a copy of the original collection of objects.</div><div>A Fail-fast iterator tries to immediately throw Exception when it</div><div>encounters failure. A Fail-safe Iterator works on a copy of</div><div>collection instead of original collection.</div>
<div>205. How does</div><div>ConcurrentHashMap work in Java?</div><div><br /></div>	<div>ConcurrentHashMap extends AbstractMap in Java. It was</div><div>introduced in Java 1.5. It provides concurrency in a collection</div><div>based on a HashMap.</div><div>All methods are thread-safe in ConcurrentHashMap.</div><div>Internally there is a Hashtable backing a ConcurrentHashMap. This</div><div>Hashtable supports the concurrent methods for retrieval of data as</div><div>well as updates on ConcurrentHashMap.</div><div>It has same functional specification as a Hashtable.</div><div>It also supports a set of sequential and bulk operations. These</div><div>operations accept parallelismThreshold argument.</div><div><br /></div>
<div>206. What is the importance of</div><div>hashCode() and equals() methods?</div>	<div>In a HashMap collection it is very important for a key object to</div><div>implement hashCode() method and equals() method. If hashCode()</div><div>method returns same hashcode for all key objects then the hash</div><div>collision will be high in HashMap. Also with same hashcode, we</div><div>will get same equals method that will make our HashMap</div><div>inefficient.</div><div>The problem arises when HashMap treats both outputs same instead</div><div>of different. It will overwrite the most recent key-value pair with</div><div>the previous key-value pair.</div><div>So it is important to implement hashCode() and equals() methods</div><div>correctly for an efficient HashMap collection.</div>
<div>207. What is the contract of</div><div>hashCode() and equals() methods in</div><div>Java?</div><div><br /></div>	<div>Contract of hashCode() and equals() methods is as follows in Java:</div><div>If object1.equals(object2), then object1.hashCode() ==</div><div>object2.hashCode() should always be true. It means if two objects</div><div>are equal then their hashCode should be same.</div><div>If object1.hashCode() == object2.hashCode() is true, it does not</div><div>guarantee that object1.equals(object2). It means if two objects have</div><div>same hashCode, then can still have different values so that may not</div><div>be equal objects.</div><div><br /></div>
<div>208. What is an EnumSet in Java?</div><div><br /></div>	<div>Set: EnumSet is a specialized implementation of Set.</div><div>1. &nbsp;Use: It is mainly used with enum types.</div><div>2. &nbsp;Single enum type: All the elements in an EnumSet must</div><div>come from a single enum type when the set is created.</div><div>3. &nbsp;Bit vector: Internally, EnumSet is represented as bit</div><div>vector.</div><div>4. &nbsp;Iterator: The iterator of EnumSet traverses the elements in</div><div>their natural order. (It is the order in which the enum</div><div>constants are declared).</div><div>5. &nbsp;Null: In an EnumSet, null elements are not permitted. If we</div><div>try to insert a null element it throws NullPointerException.</div><div>6. &nbsp;Thread-safe: EnumSet is not a synchronized collection.</div><div>For use in multi-threading scenarios, EnumSet should be</div><div>synchronized.</div><div>7. &nbsp;Bit flags: EnumSet is a very good alternative to int based</div><div>“bit flags” implementation.</div><div><br /></div>
<div>209. What are the main Concurrent</div><div>Collection classes in Java?</div><div><br /></div>	"<div>Java 1.5 has provided new package java.util.concurrent. This</div><div>package contains thread-safe collection classed. These collection</div><div>classes can be modified while iterating. The iterator of these</div><div>classes is fail-safe.</div><div>Main Concurrent Collection classes in Java 8 are:</div><div><pre class=""myCodeClass"">ArrayBlockingQueue CopyOnWriteArrayList CopyOnWriteArraySet ConcurrentHashMap ConcurrentLinkedDeque ConcurrentLinkedQueue LinkedBlockingQueue LinkedBlockingDeque PriorityBlockingQueue </pre></div>"
<div>210. How will you convert a Collection</div><div>to SynchronizedCollection in Java?</div><div><br /></div>	"<p>Java provides an easy method in java.utils.Collections class to<br /> create a ThreadSafe collection from a regular collection.<br /> We can use the method synchronizedCollection() for this purpose.<br /> For any class of type T we can use following method:</p><div class=""codehilite"" style=""background: #f8f8f8"" align=""left""><pre style=""line-height: 125%""><table><tbody><tr><td><div class=""highlight"" style=""background: #f8f8f8""><pre style=""line-height: 125%""><span style=""color: rgb(0, 128, 0)"">static</span> <span style=""color: #666666"">&lt;</span>T<span style=""color: #666666"">&gt;</span> Collection<span style=""color: #666666"">&lt;</span>T<span style=""color: #666666"">&gt;</span> <span style=""color: #0000FF"">synchronizedCollection</span><span style=""color: #666666"">(</span>Collection<span style=""color: #666666"">&lt;</span>T<span style=""color: #666666"">&gt;</span> c<span style=""color: #666666"">)</span></pre></div></td></tr></tbody></table></pre><pre style=""line-height: 125%""><br /></pre></div><!----SBAdata:eyJpc2NvbnZlcnRlZCI6ICJUcnVlIiwgImxhc3Rtb2RpZmllZCI6IDE1NTQ4ODMzMDcsICJpZCI6ICIxNTU0ODgzMjc4MDQxLTAwMSIsICJtZCI6ICJKYXZhIHByb3ZpZGVzIGFuIGVhc3kgbWV0aG9kIGluIGphdmEudXRpbHMuQ29sbGVjdGlvbnMgY2xhc3MgdG9cbmNyZWF0ZSBhIFRocmVhZFNhZmUgY29sbGVjdGlvbiBmcm9tIGEgcmVndWxhciBjb2xsZWN0aW9uLlxuV2UgY2FuIHVzZSB0aGUgbWV0aG9kIHN5bmNocm9uaXplZENvbGxlY3Rpb24oKSBmb3IgdGhpcyBwdXJwb3NlLlxuRm9yIGFueSBjbGFzcyBvZiB0eXBlIFQgd2UgY2FuIHVzZSBmb2xsb3dpbmcgbWV0aG9kOlxuICAgIFxuICAgIFxuICAgIHN0YXRpYyAmbHQ7VCZndDsgQ29sbGVjdGlvbiZsdDtUJmd0OyBzeW5jaHJvbml6ZWRDb2xsZWN0aW9uKENvbGxlY3Rpb24mbHQ7VCZndDsgYylcbiJ9---->"
<div>211. How IdentityHashMap is</div><div>different from a regular Map in Java?</div><div><br /></div>	<div>IndentityHashMap in Java implements Map interface. But it is not a</div><div>general purpose implementation. It violates the general contract of</div><div>Map interface by a different implementation of equals() method.</div><div>In an IdentityHashMap, two keys k1 and k2 are equal if and only if</div><div>(k1==k2). (In a normal Map implementation (like HashMap) two</div><div>keys k1 and k2 are considered equal if and only if (k1==null ?</div><div>k2==null : k1.equals(k2)).)</div><div>It implements the Map interface with a hash table, using reference-</div><div>equality in place of object-equality when comparing keys (and</div><div>values).</div><div><br /></div>
<div>212. What is the main use of</div><div>IdentityHashMap?</div><div><br /></div>	"<div>Main uses of IdentityHashMap are:</div><div>1. &nbsp;Topology &nbsp;Preservation: &nbsp;The &nbsp;typical &nbsp;use &nbsp;of</div><div>IdentityHashMap class is topology-preserving object</div><div>graph transformations, such as serialization or deep-</div><div>copying. In such a scenario, a program must maintain a</div><div>""node table"" to keep track of all the object references that</div><div>have already been processed.</div><div>2. &nbsp;The node table should not considered distinct objects as</div><div>equal even if they happen to be equal.</div><div>3. &nbsp;Proxy objects: Another use of this class is to maintain</div><div>proxy objects. A debugging program has to maintain a</div><div>proxy object for each object in the program being</div><div>debugged.</div>"
<div>213. How can we improve the</div><div>performance of IdentityHashMap?</div><div><br /></div>	<div>IdentityHashMap class has one tuning parameter for performance</div><div>improvement: expectedMaxSize.</div><div>This parameter is the maximum number of key-value mappings that</div><div>the map is expected to hold.</div><div>We can use this parameter is used to determine the number of</div><div>buckets initially in the hash table. The precise relationship between</div><div>the expected maximum size and the number of buckets is</div><div>unspecified.</div><div>If the number of key-value mappings exceeds the expected maximum</div><div>size, the number of buckets is increased.</div><div>Increasing the number of buckets is also known as rehashing.</div><div>Rehashing may be fairly expensive. So it is better to create identity</div><div>hash maps with a sufficiently large expected maximum size.</div><div>But iteration over a Map collection requires time proportional to</div><div>the number of buckets in the hash table. So iteration may take extra</div><div>time due to large number of buckets.</div><div>Therefore the value of expectedMaxSize should be set in</div><div>consideration with both of these aspects.</div><div><br /></div>
<div>214. Is IdentityHashMap thread-</div><div>safe?</div><div><br /></div>	<div>The implementation of IdentityHashMap is not thread-safe, since its</div><div>methods are not synchronized.</div><div>The iterators returned by the iterator method of IdentityHashMap</div><div>are fail-fast. But the fail-fast behavior of an iterator cannot be</div><div>guaranteed.</div><div>Since &nbsp;the &nbsp;Iterator &nbsp;is &nbsp;fail-fast, &nbsp;it &nbsp;throws</div><div>ConcurrentModificationException.</div>
<div>215. What is a WeakHashMap in</div><div>Java?</div><div><br /></div>	<div>WeakHashMap is a class similar to IdentityHashMap.</div><div>Internally, it is represented by a Hashtable.</div><div>It is not a synchronized class. We can make a WeakHashMap thread</div><div>safe by using Collections.synchronizedMap() method.</div><div>An entry in WeakHashMap is automatically removed when it is no</div><div>longer in ordinary use.</div><div>The presence of a mapping for a given key does not prevent the key</div><div>from being discarded by the garbage collector.</div><div>WeakHashMap also permits null keys and null values.</div><div><br /></div>
<div>216. How can you make a Collection</div><div>class read Only in Java?</div><div><br /></div>	"<div>In Java, there are useful methods to make a Collection class read</div><div>Only. We can make the Collection read Only by using one of the</div><div>following methods:</div><div><pre class=""myCodeClass""><center><table><tbody><tr><td><div class=""highlight"" style=""background: #f8f8f8""><pre style=""line-height: 125%"">Collections<span style=""color: #666666"">.</span><span style=""color: #7D9029"">unmodifiableMap</span><span style=""color: #666666"">(</span>Map m<span style=""color: #666666"">)</span> Collections<span style=""color: #666666"">.</span><span style=""color: #7D9029"">unmodifiableList</span><span style=""color: #666666"">(</span>List l<span style=""color: #666666"">)</span> Collections<span style=""color: #666666"">.</span><span style=""color: #7D9029"">unmodifiableSet</span><span style=""color: #666666"">(</span>Set s<span style=""color: #666666"">)</span> Collections<span style=""color: #666666"">.</span><span style=""color: #7D9029"">unmodifiableCollection</span><span style=""color: #666666"">(</span>Collection c<span style=""color: #666666"">)</span> </pre></div> </td></tr></tbody></table></center><br /></pre></div>"
<div>217. When is</div><div>UnsupportedOperationException</div><div>thrown in Java?</div>	"<div><div>In a Java collection <code class=""myCodeClass"">UnsupportedOperationException</code> is thrown</div><div>when the requested operation is not supported by the collection.</div><div>It is an unchecked exception that is thrown on optional operations.</div><div>If there is an optional&nbsp;<code class=""myCodeClass"">add()</code> or <code class=""myCodeClass"">remove()</code> methods in a read only&nbsp;collection, then this exception can be thrown.</div></div>"
<div>218. Let say there is a Customer</div><div>class. We add objects of Customer</div><div>class to an ArrayList. How can we</div><div>sort the Customer objects in</div><div>ArrayList by using customer</div><div>firstName attribute of Customer</div><div>class?</div>	<div>There are two ways to handle this scenario. We can use these</div><div>options:</div><div>Comparable: Implement the Comparable interface for Customer</div><div>class and compare customer objects by firstName attribute.</div><div>Comparator: Implement Comparator for comparing two Customer</div><div>objects on the basis of firstName attribute. Then use this comparator</div><div>object in sort method of Collections class.</div><div><br /></div>
<div>219. What is the difference between</div><div>Synchronized Collection and</div><div>Concurrent Collection?</div><div><br /></div>	<div>In Java 1.5 many Concurrent collection classes were added in SDK.</div><div>These &nbsp;are &nbsp;ConcurrentHashMap, &nbsp;CopyOnWriteArrayList,</div><div>BlockingQueue etc.</div><div>Java also provides utility methods to get a synchronized copy of</div><div>collection &nbsp;like &nbsp;ArrayList, &nbsp;HashMap &nbsp;etc. &nbsp;by &nbsp;using</div><div>Collections.synchronizedList(), &nbsp;Collections.synchronizedMap()</div><div>methods.</div><div>The main difference is in performance. Concurrent collection</div><div>classes have better performance than synchronized collection</div><div>classes because they lock only a portion of the class to achieve</div><div>concurrency and thread-safety.</div><div><br /></div>
<div>220. What is the scenario to use</div><div>ConcurrentHashMap in Java?</div><div><br /></div>	<div>ConcurrentHashMap is more suited for scenarios where we have</div><div>multiple reader threads and one writer thread. In this case map is</div><div>locked only during the write operation.</div><div>If we have an equal number of reader and writer threads then</div><div>ConcurrentHashMap performance is similar to a Hashtable or a</div><div>synchronized HashMap.</div><div><br /></div>
<div>221. How will you create an empty</div><div>Map in Java?</div><div><br /></div>	<div>There are two ways to create an empty Map in Java.</div><div>1. &nbsp;Immutable: If we want an immutable empty Map, we can</div><div>use following code:</div><div>myMap = Collections.emptyMap();</div><div>2. &nbsp;Any map: For all other scenarios, we can use following</div><div>code by using new method:</div><div>myMap = new HashMap();</div>
<div>222. What is the difference between</div><div>remove() method of Collection and</div><div>remove() method of Iterator?</div><div><br /></div>	<div>In Collection interface remove(Object o) method is used to remove</div><div>objects from a Collection.</div><div>List interface also provides remove(int index) method to remove an</div><div>object at a specific index.</div><div>These methods are used to remove an entry from Collection, while</div><div>no thread is iterating over it.</div><div>When we are iterating over a Collection, then we have to remove()</div><div>method of Iterator. This method removes current element from</div><div>Iterator’s point of view. If we use remove(0 method of Collection</div><div>or List, then we will get ConcurrentModificationException.</div><div>Therefore, it is recommended to use remove() method of Iterator</div><div>during the traversal of a Collection by an Iterator.</div><div><br /></div>
<div>223. Between an Array and</div><div>ArrayList, which one is the preferred</div><div>collection for storing objects?</div><div><br /></div>	<div>An ArrayList is backed up by array internally. There are many</div><div>usability advantages of using an ArrayList over an array in Java.</div><div>Array has a fixed length at the time of creation. Once it is created</div><div>we cannot change its length.</div><div>ArrayList is dynamic in size. Once it reaches a threshold, it</div><div>automatically allocates a new array and copies contents of old array</div><div>to new array.</div><div>Also ArrayList provides support of Generics. But Array does not</div><div>support Generics.</div><div>E.g. If we store an Integer object in a String array at Runtime it will</div><div>throw ArrayStoreException. Whereas, if we use ArrayList then as</div><div>compile time we will get the error. This helps in preventing errors</div><div>from happening at runtime.</div><div>If we know the size in advance and do not need re-sizing the</div><div>collection then Array should be used in place of an ArrayList.</div><div><br /></div>
<div>224. Is it possible to replace</div><div>Hashtable with ConcurrentHashMap</div><div>in Java?</div><div><br /></div>	<div>Yes, a ConcurrentHashMap can be replaced with Hashtable in Java.</div><div>But it requires careful observation, since locking behavior of</div><div>Hashtable is different than that of ConcurrentHashmap.</div><div>A Hashtable locks whole Map instead of a portion of Map.</div><div>Compound operations like if(Hashtable.get(key) == null) put(key,</div><div>value) work in Hashtable but not in ConcurrentHashMap.</div><div>In a ConcurrentHashMap we use putIfAbsent() method for such a</div><div>scenario.</div><div><br /></div>
<div>225. How CopyOnWriteArrayList</div><div>class is different from ArrayList and</div><div>Vector classes?</div><div><br /></div>	<div>CopyOnWriteArrayList was introduced in Java 1.5. It implements</div><div>List interface.</div><div>It provides better concurrent access methods than a Synchronized</div><div>List.</div><div>In CopyOnWriteList, concurrency is achieved by copying ArrayList</div><div>over each write and replace with original instead of locking.</div><div>CopyOnWriteArrayList &nbsp;also &nbsp;does &nbsp;not &nbsp;throw &nbsp;any</div><div>ConcurrentModification Exception during Iteration.</div><div>It is a thread-safe list.</div><div>It is different from a Vector in terms of Concurrency.</div><div>CopyOnWriteArrayList provides better Concurrency by reducing</div><div>contention among readers and writers.</div>
<div>226. Why ListIterator has add()</div><div>method but Iterator does not have?</div><div><br /></div>	<div>ListIterator can iterate in the both directions of a Collection. It</div><div>maintains two pointer for previous and next element. In ListIterator</div><div>we can use add() method to add an element into the list immediately</div><div>before the element returned by next() method.</div><div>So a subsequent call to next() method will not be affected. And the</div><div>call to previous() method will return the newly added element.</div><div>In Iterator we can only traverse in one direction. So there is no</div><div>purpose of add() method there.</div>
<div>227. Why do we sometime get</div><div>ConcurrentModificationException</div><div>during iteration?</div><div><br /></div>	<div>When we remove an object by using remove() method of a</div><div>Collection or List while an Iterator thread is traversing it, we get</div><div>ConcurrentModificationException. If an Iterator detects any</div><div>structural &nbsp;change &nbsp;in &nbsp;Collection &nbsp;it &nbsp;can &nbsp;throw</div><div>ConcurrentModificationException.</div><div><br /></div>
<div>228. How will you convert a Map to</div><div>a List in Java?</div><div><br /></div>	"<div>In Java, a Map has three collection sets:</div><div>key set</div><div>value set</div><div>key-value set</div><div>Each of these Sets can be converted to List by using a constructor.</div><div>Sample code is as follows:</div><div><br /></div><div><center><table><tbody><tr><td><div class=""highlight"" style=""background: #f8f8f8""><pre style=""line-height: 125%"">List keyList <span style=""color: #666666"">=</span> <span style=""color: #008000; font-weight: bold"">new</span> ArrayList<span style=""color: #666666"">(</span>map<span style=""color: #666666"">.</span><span style=""color: #7D9029"">keySet</span><span style=""color: #666666"">());</span> List valueList <span style=""color: #666666"">=</span> <span style=""color: #008000; font-weight: bold"">new</span> ArrayList<span style=""color: #666666"">(</span>map<span style=""color: #666666"">.</span><span style=""color: #7D9029"">values</span><span style=""color: #666666"">());</span> List entryList <span style=""color: #666666"">=</span> <span style=""color: #008000; font-weight: bold"">new</span> ArrayList<span style=""color: #666666"">(</span>map<span style=""color: #666666"">.</span><span style=""color: #7D9029"">entrySet</span><span style=""color: #666666"">());</span> </pre></div> </td></tr></tbody></table></center><br /></div>"
<div>229. How can we create a Map with</div><div>reverse view and lookup in Java?</div><div><br /></div>	<div>In a Map we can lookup for a value by using a distinct key. In a Map</div><div>with reverse view and lookup, even the values are distinct. So there</div><div>is one to one mapping between keys and values and vice version.</div><div>If we enable this constraint on a Map then we can look up a key by</div><div>its value. Such data structure is called bi-directional map.</div><div>There is no built data structure similar to reverse lookup Map in</div><div>JDK.</div><div>But Apache Common Collections and Guava libraries provide</div><div>implementation of bidirectional map. It is called BidiMap and</div><div>BiMap. Both of these data structure enforce the constraint of one to</div><div>one mapping between keys and values.</div><div><br /></div>
<div>230. How will you create a shallow</div><div>copy of a Map?</div><div><br /></div>	<div>In Java, most implementations of Map interface provide a</div><div>constructor to create copy of another map. But the copy method is</div><div>not synchronized.</div><div>Therefore, when a thread is copying the map, another thread can</div><div>modify it.</div><div>To &nbsp;prevent &nbsp;such &nbsp;a &nbsp;scenario, &nbsp;we &nbsp;should &nbsp;use</div><div>Collections.synchronizedMap() method to first create a thread-safe</div><div>map.</div><div>Another way of to create a shallow copy is by using clone() method.</div><div>But it is not considered as a recommended approach.</div><div><br /></div>
<div>231. Why we cannot create a generic</div><div>array in Java?</div><div><br /></div>	<div>Java does not allow creation of array with generics as elements.</div><div>In Java an array has to know the type information of its elements at</div><div>runtime.</div><div>This information is used at runtime to throw ArrayStoreException if</div><div>data type of an element to be inserted does not match the type of</div><div>Array.</div><div>In case of Generics, the type information of a collection is erased at</div><div>runtime by Type Erasure. Due to this array cannot use generics as</div><div>elements.</div><div><br /></div>
<div>232. What is a PriorityQueue in</div><div>Java?</div><div><br /></div>	<div>A PriorityQueue is data structure based on Queue. Unlike Queue,</div><div>the elements on PriorityQueue are not returned in FIFO order.</div><div>A PriorityQueue maintains the natural order of its elements or it</div><div>uses a Comparator provided at initialization.</div><div>It is an unbounded queue based on a priority heap.</div><div>PriorityQueue does not allow null values. We cannot add any object</div><div>that does not provide natural ordering to PriorityQueue.</div><div>PriorityQueue in Java is not thread-safe.</div><div>It gives O(log n) time for enqueing and dequeing operations.</div><div><br /></div>
<div>233. What are the important points</div><div>to remember while using Java</div><div>Collections Framework?</div><div><br /></div>	<div>Some of the important points to remember while using Java</div><div>Collections Framework are:</div><div>1. &nbsp;Interfaces: For Collections, we should write code with</div><div>generic interfaces instead of concrete implementation. Due</div><div>to this we maintain the flexibility of changing the</div><div>implementation at a later point of time.</div><div>2. &nbsp;Generics: We should use Generics for type-safety and to</div><div>avoid ClassCastException at runtime.</div><div>3. &nbsp;Collections: It is recommended to use Collections utility</div><div>class for algorithms and various other common methods</div><div>for Collections.</div><div>4. &nbsp;Right Type: We have to choose the right type of Java</div><div>collection based on our need. If size is fixed, we can use</div><div>Array over ArrayList. If we do not want duplicate</div><div>elements we use Set.</div><div>If we need the ability to iterate the elements of a Map in</div><div>the order of insertion then we use a TreeMap.</div><div>5. &nbsp;Initial Size: In some collection classes we can specify the</div><div>initial size/capacity. Therefore we should have an estimate</div><div>of number of elements in a Collection before deciding the</div><div>right collection type. We can use it to avoid rehashing or</div><div>resizing.</div><div>6. &nbsp;Map: We should use immutable classes provided by Java</div><div>as key elements in a Map.</div><div><br /></div>
<div>234. How can we pass a Collection</div><div>as an argument to a method and</div><div>ensure that method will not be able to</div><div>modify it?</div><div><br /></div>	<div>To ensure that a method is not able to modify a Collection passed as</div><div>an argument, we have to make the Collection read only.</div><div>We &nbsp;can &nbsp;make &nbsp;a &nbsp;read &nbsp;only &nbsp;collection &nbsp;by &nbsp;using</div><div>Collections.unmodifiableCollection(Collection c) method.</div><div>This will make sure that any operation to change the collection will</div><div>throw UnsupportedOperationException.</div><div><br /></div>
<div>235. Can you explain how</div><div>HashMap works in Java?</div><div><br /></div>	<div>In Java, a HashMap works on the concept of hashing.</div><div>A HashMap in Java stores both key and value objects, in a bucket. It</div><div>is stored as an Entry object that implements Map.Entry interface.</div><div>The key object used in a HashMap has to provide implementation</div><div>for hashCode() and equals() methods.</div><div>When put() method is used to store a key-value pair, the HashMap</div><div>implementation calls hashCode() method on Key object to calculate</div><div>a hash that is used to find a bucket where Entry object will be</div><div>stored.</div><div>When get() method is used to retrieve a value stored against a key</div><div>object, we first calculate a hash of Key object. Then we use this</div><div>hash to find the bucket in which that particular key is stored.</div><div>Once Key object’s location is found, it may happen that more than</div><div>one Key is stored in same location. So now we use equals() method</div><div>to find the exact Key object. Once the exact Key object is found we</div><div>use it to get Value object.</div><div><br /></div>
<div>236. Can you explain how HashSet</div><div>is implemented in Java?</div><div><br /></div>	<div>Internally, a HashSet uses a HashMap to store the elements and to</div><div>maintain the uniqueness of elements.</div><div>When we create a HashSet object, a corresponding HashMap object</div><div>is also created.</div><div>When we insert an element in HashSet, it inserts it into</div><div>corresponding HashMap.</div><div><br /></div>
<div>237. What is a NavigableMap in</div><div>Java?</div><div><br /></div>	<div>As the name suggests, NavigableMap provides the capability to</div><div>navigate the keys of a Map in Java. A NavigableMap extends</div><div>SortedMap interface.</div><div>Some of the interesting methods of a NavigableMap are</div><div>descendingKeySet(), descendingMap(), headMap() and tailMap().</div>
<div>238. What is the difference between</div><div>descendingKeySet() and</div><div>descendingMap() methods of</div><div>NavigableMap?</div><div><br /></div>	<div>The descendingKeySet() method of NavigableMap returns a</div><div>NavigableSet in which the elements are stored in reversed order as</div><div>compared to the original key set.</div><div>The returned view is internally represented by the original KeySet</div><div>of NavigableMap. Therefore any changes to the descending set also</div><div>get reflected in the original set.</div><div>But it is not recommended to remove elements directly from the key</div><div>set. We should use the Map.remove() method.</div><div>The descendingMap() method of NavigableMap returns a</div><div>NavigableMap which is an inverse view of the original Map. The</div><div>order of the elements in this view are in reverse order of the</div><div>elements in original map. Any changes to this view are also</div><div>reflected in the original map.</div><div><br /></div>
<div>239. What is the advantage of</div><div>NavigableMap over Map?</div><div><br /></div>	<div>The main advantage of NavigableMap over Map is the Navigation</div><div>capability.</div><div>It provides the capabilities of a Map, SortedMap and navigation in</div><div>one collection.</div><div>It even returns the closest matches for given search targets.</div><div>Methods like lowerEntry, floorEntry, ceilingEntry, and higherEntry</div><div>return Map.Entry objects associated with keys respectively less</div><div>than, less than or equal, greater than or equal, and greater than a</div><div>given key.</div><div>Methods like lowerKey, floorKey, ceilingKey, and higherKey return</div><div>only the associated keys. All of these methods are designed for</div><div>locating, not traversing entries.</div><div><br /></div>
<div>240. What is the difference between</div><div>headMap(), tailMap() and subMap()</div><div>methods of NavigableMap?</div>	"<div>The headMap() method returns a view of the original</div><div>NavigableMap that contains the elements that are less than a given</div><div>element.</div><div>NavigableMap original = new TreeMap();</div><div>original.put(""1"", ""1"");</div><div>original.put(""2"", ""2"");</div><div>original.put(""3"", ""3"");</div><div>//this headmap1 will contain elements ""1"" and ""2""</div><div>SortedMap headmap1 = original.headMap(""3"");</div><div>//this headmap2 will contain elements ""1"", ""2"", and ""3"" because</div><div>""inclusive""=true</div><div>NavigableMap headmap2 = original.headMap(""3"", true);</div><div>The tailMap() method works similar to headMap() method, but it</div><div>returns all elements that are higher than the given input element.</div><div>The subMap() method accepts two parameters demarcating the</div><div>boundaries of the view map to return.</div><div>All the three methods return a subset of the original map in a view</div><div>form.</div><div><br /></div>"
<div>241. How will you sort objects by</div><div>Natural order in a Java List?</div><div><br /></div>	<div>We can use Collections.sort method to sort the elements of a List in</div><div>natural order. To use this method, we have to make sure that element</div><div>objects implement compareTo() method.</div><div>We can also use a Comparator to define the natural ordering for</div><div>elements of a List. Then we can use this Custom Comparator in sort</div><div>method of Collections class.</div><div><br /></div>
<div>242. How can we get a Stream from</div><div>a List in Java?</div><div><br /></div>	<div>From Java 8 onwards it is a very easy to get a Stream from a List.</div><div>We can just use stream() method to get a stream from a list of</div><div>elements.</div><div><br /></div>
<div>243. Can we get a Map from a</div><div>Stream in Java?</div><div><br /></div>	<div>Yes, we can create a Map from the elements of a Stream. We can</div><div>use map() method to get a Map.</div><div>E.g. items.stream()</div><div>.map( item -&gt; item.toLowerCase() )</div><div>In this example we are creating a map with each item object</div><div>mapped to its LowerCase equivalent.</div><div>This is also used in Map-Reduce implementation on a Stream.</div><div><br /></div>
<div>244. What are the popular</div><div>implementations of Deque in Java?</div><div><br /></div>	<div>The two most popular implementation of Deque interface in Java</div><div>are:</div><div>1. ArrayDeque: It is a resizable array implementation of</div><div>Deque. The capacity of ArrayDeque can increase based</div><div>on the need of the program. It is not thread safe</div><div>implementation. Also the iterator on ArrayDeque is fail-</div><div>fast.</div><div>2. LinkedList: This is another popular implementation of</div><div>Deque interface in Java. It is also not synchronized, so it</div><div>is not thread-safe. It mainly provides functionality of a</div><div>doubly linked list.</div><div><br /></div>
<div>245. What is a Thread in Java?</div><div><br /></div>	<div>A thread in Java is a lightweight process that runs within another</div><div>process or thread.</div><div>It is an independent path of execution in an application. JVM gives</div><div>each thread its own method-call stack.</div><div>When we start JVM, Java starts one thread. This thread calls the</div><div>main method of the class passed in argument to java call.</div><div><br /></div>
<div>246. What is the priority of a</div><div>Thread and how it is used in</div><div>scheduling?</div><div><br /></div>	<div>In Java, every Thread has a priority. This priority is specified as a</div><div>number between 1 to 10.</div><div>Scheduler in Java schedules different threads based on the priority</div><div>of a thread. It is also known as pre-emptive scheduling.</div><div>The thread with higher priority gets preference in execution over a</div><div>thread with lower priority.</div>
<div>247. What is the default priority of</div><div>a thread in Java?</div><div><br /></div>	<div>In Java, a new thread gets the same priority as the priority of the</div><div>parent thread that creates it.</div><div>Default priority of a thread is 5 (NORM_PRIORITY).</div><div><br /></div>
<div>248. What are the three different</div><div>priorities that can be set on a Thread</div><div>in Java?</div><div><br /></div>	"<div>We can set following three priorities on a Thread object in Java:</div><div>1. &nbsp;MIN_PRIORITY: This is the minimum priority that a</div><div>thread can have.</div><div>2. &nbsp;NORM_PRIORITY: This is the default priority that is</div><div>assigned to a thread.</div><div>3. &nbsp;MAX_PRIORITY: This is the maximum priority that a</div><div>thread can have.</div><div>Default priority of a thread is 5 NORM_PRIORITY. The value of</div><div>MIN_PRIORITY is 1 and the value of MAX_PRIORITY is 10.</div><div>249. What is the purpose of join()</div><div>method in Thread class?</div><div>In Java, Thread Scheduler controls thread scheduling. But we can</div><div>use join() method on a thread to make current thread to wait for</div><div>another thread to finish.</div><div>When we use join(), the current thread stops executing. It wait for</div><div>the thread on which join() is called to finish.</div><div>This makes sure that current thread will continue only after the</div><div>thread it joined finished running. Consider following example:</div><div><br /></div><div><center><table><tbody><tr><td><div class=""highlight"" style=""background: #f8f8f8""><pre style=""line-height: 125%""><span style=""color: #008000;font-weight: bold"">public</span> <span style=""color: #008000; font-weight: bold"">class</span> <span style=""color: #0000FF; font-weight: bold"">ThreadJoin</span> <span style=""color: #666666"">{</span>   Thread importantThread <span style=""color: #666666"">=</span> <span style=""color: #008000; font-weight: bold"">new</span> Thread<span style=""color: #666666"">(</span> <span style=""color: #008000; font-weight: bold"">new</span> Runnable<span style=""color: #666666"">()</span> <span style=""color: #666666"">{</span>     <span style=""color: #008000; font-weight: bold"">public</span> <span style=""color: #B00040"">void</span> <span style=""color: #0000FF"">run</span> <span style=""color: #666666"">()</span> <span style=""color: #666666"">{</span>       <span style=""color: #408080; font-style: italic"">//do something</span>     <span style=""color: #666666"">}</span><span style=""color: #666666"">);</span>  Thread currentThread <span style=""color: #666666"">=</span> <span style=""color: #008000; font-weight: bold"">new</span> Thread<span style=""color: #666666"">(</span> <span style=""color: #008000; font-weight: bold"">new</span> Runnable<span style=""color: #666666"">()</span> <span style=""color: #666666"">{</span>     <span style=""color: #008000; font-weight: bold"">public</span> <span style=""color: #B00040"">void</span> <span style=""color: #0000FF"">run</span> <span style=""color: #666666"">()</span> <span style=""color: #666666"">{</span>       <span style=""color: #408080; font-style: italic"">//do something</span>     <span style=""color: #666666"">}</span> <span style=""color: #666666"">});</span>    importantThread<span style=""color: #666666"">.</span><span style=""color: #7D9029"">start</span><span style=""color: #666666"">();</span> <span style=""color: #408080; font-style: italic"">// Line 1</span>   importantThread<span style=""color: #666666"">.</span><span style=""color: #7D9029"">join</span><span style=""color: #666666"">();</span> <span style=""color: #408080; font-style: italic"">// Line 2</span>   currentThread<span style=""color: #666666"">.</span><span style=""color: #7D9029"">start</span><span style=""color: #666666"">();</span> <span style=""color: #408080; font-style: italic"">// Line 3</span>  <span style=""color: #666666"">}</span> </pre></div> </td></tr></tbody></table></center><br /></div><div>In the above example, main thread is executing. On Line 1, a new</div><div>thread called importantThread is ready to run. But at Line 2, main</div><div>thread joins the importantThread. Now it lets importantTread to</div><div>finish and then it moves to Line 3. So currentThread at Line 3 will</div><div>not start till the importantThread has finished.</div><div><br /></div>"
<div>250. What is the fundamental</div><div>difference between wait() and sleep()</div><div>methods?</div><div><br /></div>	<div>The main difference between wait() and sleep() is that wait is an</div><div>Object level method, whereas sleep() is a static method in Thread</div><div>class. A waiting thread can be woken up by another thread by</div><div>calling notify() on the monitor which is being waited on. But a</div><div>sleeping thread cannot be woken up.</div><div>A wait() and notify() has to happen within the same block that is</div><div>synchronized on the monitor object.</div><div>When we call wait() the current thread releases the monitor and</div><div>goes to waiting state. Then another thread calls notify() to wake it</div><div>up.</div><div>In case of sleep() current thread does not release the monitor or</div><div>locks. It just sleeps for some pre-defined time period.</div><div><br /></div>
<div>251. Is it possible to call run() method</div><div>instead of start() on a thread in Java?</div><div><br /></div>	<div>Yes. We can call run() method of a thread. But it does not work as a</div><div>separate thread. It will just work as a normal object in main thread</div><div>and there will not be context switching between the threads.</div><div><br /></div>
<div>252. How Multi-threading works in</div><div>Java?</div><div><br /></div>	<div>Java provides support for Multithreading. In a Multithreading</div><div>environment, one process can execute multiple threads in parallel at</div><div>the same time.</div><div>In Java, you can create process and then create multiple threads</div><div>from that process. Each process can execute in parallel to perform</div><div>independent tasks.</div><div>Java provides methods like- start(), notify(), wait(), sleep() etc. to</div><div>maintain a multi-threading environment.</div><div><br /></div>
<div>253. What are the advantages of</div><div>Multithreading?</div><div><br /></div>	<div>Main advantages of Multithreading are:</div><div>1. &nbsp;Improved performance: We can improve performance of a</div><div>job by Multi-threading.</div><div>2. &nbsp;Simultaneous access to Multiple Applications: We can</div><div>access multiple applications from a process by doing</div><div>multithreading</div><div>3. &nbsp;Reduced number of Servers required: With Multi-</div><div>threading we need lesser number of servers, since one</div><div>process can spawn multiple threads.</div><div>4. &nbsp;Simplified Coding: In certain scenarios, it is easier to</div><div>code multiple threads than managing it from same thread.</div><div><br /></div>
<div>254. What are the disadvantages of</div><div>Multithreading?</div><div><br /></div>	<div>There are certain downsides to Multithreading. These are:</div><div>1. &nbsp;Difficult to Debug: Multithreading code is difficult to</div><div>debug in case of an issue.</div><div>2. &nbsp;Difficult to manage concurrency: Due to multiple threads,</div><div>we may experience different kinds of issues.</div><div>3. &nbsp;Difficulty of porting code: It is difficult to convert existing</div><div>single threaded code into multi-threading code.</div><div>4. &nbsp;Deadlocks: In case of multi-threading we can experience</div><div>deadlocks in threads that are waiting for same resource.</div><div><br /></div>
<div>255. What is a Thread in Java?</div><div><br /></div>	<div>In Java, a thread is a lightweight process that runs within another</div><div>process or thread. It is an independent path of execution in an</div><div>application. Each thread runs in a separate stack frame.</div><div>By default Java starts one thread when the main method of a class is</div><div>called.</div>
<div>256. What is a Thread’s priority</div><div>and how it is used in scheduling?</div><div><br /></div>	<div>In Java, every Thread has a priority. This priority is specified as an</div><div>integer value. The priority value is used in scheduling to pick up the</div><div>thread with higher priority for execution. The threads with higher</div><div>priority get more preference in execution than the threads with</div><div>lower priority.</div><div>The task scheduler schedules the higher priority threads first,</div><div>followed by the lower priority threads.</div>
<div>257. What are the differences</div><div>between Pre-emptive Scheduling</div><div>Scheduler and Time Slicing</div><div>Scheduler?</div><div><br /></div>	<div>In Pre-emptive scheduling, the highest priority task will keep getting</div><div>time to execute until it goes to waiting state or dead state or a task</div><div>with higher priority comes into queue for scheduling.</div><div>In Time slicing scheduling, every task gets a predefined slice of</div><div>time for execution, and then it goes to the pool of tasks ready for</div><div>execution. The scheduler picks up the next task for execution, based</div><div>on priority and various other factors.</div>
<div>258. Is it possible to call run()</div><div>method instead of start() on a thread</div><div>in Java​?</div><div><br /></div>	<div>Yes. We can call run() method of a thread. But it does not work as a</div><div>separate thread. It will just work as a normal object in main thread</div><div>and there will not be context-switching between the threads.</div>
<div>259. How will you make a user</div><div>thread into daemon thread if it has</div><div>already started?</div><div><br /></div>	<div>No. We cannot make a user thread to daemon thread once it has</div><div>already started.</div><div>If &nbsp;we &nbsp;do &nbsp;it &nbsp;by &nbsp;calling &nbsp;setDaemon(), &nbsp;it &nbsp;will &nbsp;throw</div><div>IllegalThreadStateException</div>
<div>260. Can we start a thread two</div><div>times in Java?</div><div><br /></div>	<div>No. We can call start() method only once on a thread in Java. If we</div><div>call it twice, it will give us exception.</div>
